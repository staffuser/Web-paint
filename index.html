<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Web-paint</title>
    <meta name="автор" content="https://github.com/localhost-four/">
    <meta name="оисание" content="It is a standalone image annotation application packaged in a single HTML file (200 KB) that runs in most modern web browsers.">

  

    <!-- CSS -->
    <style type="text/css">
      body {
      min-width: 800px;
      padding: 0;
      margin: 0;
      font-family: sans-serif;
      }

      /* Верхняя панель : #navbar, #toolbar */
      .top_panel {
      position: fixed;
      top: 0;
      left: 0;
      display: block;
      font-size: medium;
      background-color: #080808;
      color: rgb(235, 235, 235);
      z-index: 10;
      margin: 0;
      padding: 0;
      width: 100%;
      }

      .navbar {
      display: inline-block;
      }
      .navbar ul {
      display: inline;
      list-style-type: none;
      overflow: hidden;
      }
      .navbar li {
      float: left;
      }
      .navbar li a, .drop_menu_item {
      display: inline-block;
      color: rgb(235, 235, 235);
      padding: 0.65em 1.2em;
      text-decoration: none;
      }
      .navbar li a:hover, .dropdown:hover {
      background-color: #999999;
      cursor: pointer;
      }
      .navbar li.dropdown {
      display: inline-block;
      }
      .navbar .dropdown-content {
      display: none;
      position: absolute;
      background-color: #333333;
      min-width: 120px;
      border: 1px solid #ffffff;
      font-size: small;
      }
      .navbar .dropdown-content a {
      color: #ffffff;
      padding: 0.4em 0.6em;
      text-decoration: none;
      display: block;
      text-align: left;
      background-color: #333333;
      float: none;
      }
      .navbar .dropdown-content a:hover {
      background-color: #000000;
      color: #ffff00;
      }
      .navbar .dropdown:hover .dropdown-content {
      display: block;
      }

      .toolbar {
      display: inline-block;
      color: rgb(235, 235, 235);
      vertical-align: top;
      }
      .toolbar ul {
      display: inline;
      list-style-type: none;
      overflow: hidden;
      }
      .toolbar li {
      font-size: medium;
      float: left;
      padding: 0.65em 0.3em;
      color: rgb(235, 235, 235);
      }
      .toolbar li:hover {
      background-color: #353333;
      color: rgb(224, 3, 3);
      cursor: pointer;
      }

      #fileinfo {
      font-size: small;
      padding: 1.2em 0.8em;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      }

      /* Панель по середине: containing #image_panel, #leftsidebar */
      .middle_panel {
      position: relative;
      display: table;
      table-layout: fixed;
      width: 100%;
      z-index: 1;
      padding: 0;
      top: 3.5em;
      /*Верхняя родбивка: 1.0125em;  гарантирует, что координаты события мыши (x,y) являются integer */
      }
      #leftsidebar {
      display: table-cell;
      width: 250px;
      z-index: 10;
      vertical-align: top;
      }
      #display_area {
      display: table-cell;
      width: 100%;
      z-index: 1;
      margin: 0;
      padding-left: 1em;
      vertical-align: top;
      }
      #canvas_panel {
      position: relative;
      margin: 0;
      padding: 0;
      }
      #canvas_panel canvas:focus {
      outline: none;
      }
      #leftsidebar_collapse_panel {
      display: table-cell;
      position: relative;
      width: 10px;
      z-index: 1;
      vertical-align: top;
      font-size: small;
      }
      #leftsidebar_collapse_button {
      background-color: rgb(5, 5, 5);
      width: 10px;
      height: 25px;
      color: rgb(235, 235, 235);
      padding: 0.2em;
      border-radius: 0px 5px 5px 0px;
      font-size: large;
      }
      #leftsidebar_collapse_button:hover {
      color: rgb(155, 2, 2);
      cursor: pointer;
      }

      /* Left sidebar accordion */
      button.leftsidebar_accordion {
      font-size: large;
      background-color: #f5ebeb;
      cursor: pointer;
      padding: 0.5em 0.5em;
      width: 100%;
      text-align: left;
      border: 0;
      outline: none;
      }
      button.leftsidebar_accordion:focus {
      outline: none;
      }
      button.leftsidebar_accordion.active, button.leftsidebar_accordion:hover {
      background-color: #e6e6e6;
      }
      button.leftsidebar_accordion:after {
      content: '\02795';
      color: #444141;
      float: right;
      }
      button.leftsidebar_accordion.active:after {
      content: '\2796';
      }
      .leftsidebar_accordion_panel {
      display: none;
      padding-top: 0;
      padding-left: 0.5em;
      font-size: small;
      border-right: 2px solid #f5ebeb;
      border-bottom: 2px solid #f5ebeb;
      }
      .leftsidebar_accordion_panel.show {
      display: block;
      }

      /* Панель выбора формы области внутри левой боковой панели */
      ul.region_shape {
      font-size: xx-large;
      list-style-type: none;
      overflow: hidden;
      padding: 0.4em 0;
      margin: 0;
      }
      ul.region_shape li{
      float: left;
      padding: 0 0.2em;
      fill: #ffffff;
      stroke: #000000;
      }
      ul.region_shape li:hover {
      cursor: pointer;
      fill: #ffffff;
      stroke: #ff0000;
      }
      ul.region_shape .selected {
      fill: #ffffff;
      stroke: #ff0000;
      }

      /* Список загруженных изображений, который отображается на левой боковой панели */
      #img_fn_list {
      font-size: small;
      overflow: scroll;
      min-height: 10rem;
      max-height: 30rem;
      }
      #img_fn_list_panel input {
      width: 88%;
      border: 1px solid #ccc;
      margin: 0.6rem 0;
      padding: 0.2rem 0.4rem;
      }
      #img_fn_list ul {
      position: relative;
      line-height: 1.3em;
      margin: 0;
      padding: 0;
      list-style-type: none;
      }
      #img_fn_list li {
      white-space: nowrap;
      }
      #img_fn_list li:hover {
      background-color: #cccccc;
      color: #000000;
      cursor: pointer;
      }

      #message_panel {
      position: fixed;
      left: 0;
      bottom: 0px;
      line-height: 3em;
      width: 100%;
      background-color: #000000;
      color: #ffff00;
      font-size: small;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      z-index: 1000;
      }

      #invisible_file_input {
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      position: absolute;
      z-index: -1;
      }

      .text_panel {
      display: none;
      margin: auto;
      font-size: medium;
      line-height: 1.3em;
      margin: 0;
      max-width: 700px;
      }
      .text_panel li {
      margin: 1em 0;
      text-align: left;
      }
      .text_panel p {
      text-align: left;
      }

      .action_text_link {
      background-color: #aaeeff;
      color: #000000;
      }
      .action_text_link:hover {
      cursor: pointer;
      }

      .svg_button:hover {
      cursor: pointer;
      }

      .tool_button {
      color: blue;
      cursor: pointer;
      }
      .tool_button:hover {
      color: red;
      }

      /* панель ввода области и атрибутов файла (в виде электронной таблицы) */
      #attributes_panel {
      display: none;
      position: fixed;
      bottom: 0;
      z-index: 10;
      width: 100%;
      max-height: 30%;
      overflow: auto;
      background-color: #ffffff;
      border-top: 4px solid #000000;
      padding: 0em 0em;
      padding-bottom: 2em;
      font-size: small;
      }
      #attributes_panel table {
      border-collapse: collapse;
      table-layout: fixed;
      margin: 1em;
      margin-bottom: 2em;
      }

      #attributes_panel td {
      border: 1px solid #999999;
      padding: 1em 1em;
      margin: 0;
      height: 1em;
      white-space: nowrap;
      vertical-align: top;
      }
      #attributes_panel tr:first-child td, #attributes_panel td:first-child {
      padding: 1em 1em;
      text-align: center;
      }
      #attributes_panel input {
      border: none;
      padding: 0;
      margin: 0;
      display: table-cell;
      height: 1.3em;
      font-size: small;
      background-color: #ffffff;
      vertical-align: top;
      }
      #attributes_panel input:hover {
      background-color: #e6e6e6;
      }
      #attributes_panel input:focus {
      background-color: #e6e6e6;
      }
      #attributes_panel input:not(:focus) {
      text-align: center;
      }
      #attributes_panel textarea {
      border: none;
      padding: 0;
      margin: 0;
      display: table-cell;
      font-size: small;
      background-color: #ffffff;
      }
      #attributes_panel textarea:hover {
      background-color: #e6e6e6;
      }
      #attributes_panel textarea:focus {
      background-color: #e6e6e6;
      }

      #attributes_panel_toolbar {
      display: block;
      height: 30px;
      width: 100%;
      position: relative;
      padding: 0;
      margin: 0;
      }
      .attributes_panel_button {
      width: 10px;
      color: rgb(5, 5, 5);
      font-size: x-large;
      margin-left: 0.5em;
      padding: 0;
      }
      .attributes_panel_button:hover {
      color: rgb(182, 2, 2);
      cursor: pointer;
      }

      /* layers of canvas */
      #image_panel {
      position: relative;
      display: inline-block;
      margin: auto;
      margin-top: 1em;
      }
      #image_canvas {
      position: absolute;
      top: 0px;
      left: 0px;
      z-index: 1;
      }
      #region_canvas {
      position: absolute;
      top: 0px;
      left: 0px;
      z-index: 2;
      }
      /* Loading spinbar */
      .loading_spinbox {
      display: inline-block;
      border: 0.4em solid #cccccc;
      border-radius: 50%;
      border-top: 0.4em solid #000000;
      -webkit-animation: spin 2s linear infinite;
      animation: spin 2s linear infinite;
      }
      @-webkit-keyframes spin {
      0% { -webkit-transform: rotate(0deg); }
      100% { -webkit-transform: rotate(360deg); }
      }
      @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
      }
    </style>
  </head>

  <body onload="_init()" onresize="_update_ui_components()">
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <defs>
        <symbol id="shape_rectangle">
          <title>Прямоугольная область</title>
          <rect width="20" height="12" x="6" y="10" stroke-width="2"/>
        </symbol>
        <symbol id="shape_circle">
          <title>Круглая область</title>
          <circle r="10" cx="16" cy="16" stroke-width="2"/>
        </symbol>
        <symbol id="shape_ellipse">
          <title>Овальная область</title>
          <ellipse rx="12" ry="8" cx="16" cy="16" stroke-width="2"/>
        </symbol>
        <symbol id="shape_polygon">
          <title>Область ломанной фигуры</title>
          <path d="M 15.25,2.2372 3.625,11.6122 6,29.9872 l 20.75,-9.625 2.375,-14.75 z" stroke-width="2"/>
        </symbol>
        <symbol id="shape_point">
          <title>Точечная область</title>
          <circle r="3" cx="16" cy="16" stroke-width="2"/>
        </symbol>
        <symbol id="shape_polyline">
          <title>Область с помощью кривой</title>
          <!--<path d="M 15.25,2.2372 3.625,11.6122 6,29.9872 l 20.75,-9.625" stroke-width="2"/>-->
          <path d="M 2,12 10,24 18,12 24,18" stroke-width="2"/>
          <circle r="1" cx="2" cy="12" stroke-width="2"/>
          <circle r="1" cx="10" cy="24" stroke-width="2"/>
          <circle r="1" cx="18" cy="12" stroke-width="2"/>
          <circle r="1" cx="24" cy="18" stroke-width="2"/>
        </symbol>
      </defs>
    </svg>

    <div class="top_panel" id="ui_top_panel">
      <!-- Меню навигации -->
      <div class="navbar">
        <ul>
          <li><a onclick="show_home_panel()" title="На главную">На главную</a></li>
          <li class="dropdown"><a title="Изображение" class="drop_menu_item">Изображение &#9662;</a>
            <div class="dropdown-content">
              <a onclick="sel_local_images()" title="Загрузить (или добавить) набор выбранных изображений с локального устройства">Загрузить или добавить изображение</a>
              <a onclick="toggle_img_fn_list_visibility()" title="Просмотр загруженных изображений">Список изображений</a>
            </div>
          </li>
          <li class="dropdown"><a title="Аннотации" class="drop_menu_item">Аннотации &#9662;</a>
            <div class="dropdown-content">
              <a onclick="show_annotation_data()" title="Посмотреть аннотвции">Посмотреть аннотвции</a>
              <a onclick="download_all_region_data('csv')" title="Сохранить аннотации к областям изображения в виде файла CSV (comma separated value)">Сохранить как CSV</a>
              <a onclick="download_all_region_data('json')" title="Сохранить аннотации к областям изображения в виде файла JSON(Javascript Object Notation)">Сохранить как JSON</a>
              <a onclick="sel_local_data_file('annotations')" title="Импортируйте существующие данные из файла CSV или JSON">Импорт</a>
            </div>
          </li>
          <li class="dropdown"><a title="Вид" class="drop_menu_item">Вид &#9662;</a>
            <div class="dropdown-content">
              <a onclick="toggle_leftsidebar()" title="Показать/скрыть левую боковую панель">Показать/скрыть левую боковую панель</a>
              <a onclick="toggle_region_boundary_visibility()" title="Показать/скрыть границы областей">Показать/скрыть границы областей</a>
              <a onclick="toggle_region_id_visibility()" title="Показать/скрыть метки областей">Показать/скрыть метки областей</a>
            </div>
          </li>
          <li class="dropdown"><a onclick="show_about_panel()" title="Помощь">Помощь &#9662;</a>
            <div class="dropdown-content">
              <a onclick="show_getting_started_panel()" title="Начало работы с  VKR">Начало работы</a>
            </div>
          </li>
        </ul>

      </div> <!-- конец #navbar -->

      <!-- Панель быстрого доступа -->
      <div class="toolbar">
        <ul>

          <li id="toolbar_prev_img" style="margin-left: 1em;" onclick="move_to_prev_image()" title="Предыдущее изображение">&larr;</li>
          <li id="toolbar_next_img" onclick="move_to_next_image()" title="Следующее изображение">&rarr;</li>
          <li id="toolbar_list_img" onclick="toggle_img_list()" title="Список изображений">&#9776;</li>

          <li id="toolbar_zoom_out" style="margin-left: 2em;" onclick="zoom_out()" title="Отдалить">&minus;</li>
          <li id="toolbar_zoom_in" onclick="zoom_in()" title="Приблизить">&plus;</li>
          <li id="toolbar_zoom_reset" onclick="reset_zoom_level()" title="Сбросить приближение">&equals;</li>

          <li id="toolbar_copy_region" style="margin-left: 2em;" onclick="copy_sel_regions()" title="Скопировать область">c</li>
          <li id="toolbar_paste_region" onclick="paste_sel_regions()" title="Вставить область">v</li>
          <li id="toolbar_sel_all_region" onclick="sel_all_regions()" title="Выбрать все области">a</li>
          <li id="toolbar_del_region" onclick="del_sel_regions()" title="Удалить область">&times;</li>
        </ul>
      </div> <!-- конец #toolbar -->
      <input type="file" id="invisible_file_input" multiple name="files[]" style="display:none">
    </div> <!-- конец #top_panel -->

    <!-- Центральная панель содержит левую боковую панель и области отображения изображений -->
    <div class="middle_panel">
      <div id="leftsidebar">
        <button class="leftsidebar_accordion active">Форма области</button>
        <div class="leftsidebar_accordion_panel show">
          <ul class="region_shape">
            <li id="region_shape_rect" class="selected" onclick="select_region_shape('rect')" title="Прямоугольник"><svg height="32" viewbox="0 0 32 32"><use xlink:href="#shape_rectangle"></use></svg></li>
            <li id="region_shape_circle" onclick="select_region_shape('circle')" title="Круг"><svg height="32" viewbox="0 0 32 32"><use xlink:href="#shape_circle"></use></svg></li>
            <li id="region_shape_ellipse" onclick="select_region_shape('ellipse')" title="Овал"><svg height="32" viewbox="0 0 32 32"><use xlink:href="#shape_ellipse"></use></svg></li>
            <li id="region_shape_polygon" onclick="select_region_shape('polygon')" title="Ломанная фигура"><svg height="32" viewbox="0 0 32 32"><use xlink:href="#shape_polygon"></use></svg></li>
            <li id="region_shape_point" onclick="select_region_shape('point')" title="Точка"><svg height="32" viewbox="0 0 32 32"><use xlink:href="#shape_point"></use></svg></li>
            <li id="region_shape_polyline" onclick="select_region_shape('polyline')" title="Ломанная линия"><svg height="32" viewbox="0 0 32 32"><use xlink:href="#shape_polyline"></use></svg></li>
          </ul>
        </div>

        <button class="leftsidebar_accordion active" id="loaded_img_panel_title">Загруженные изображения</button>
        <div class="leftsidebar_accordion_panel show" id="img_fn_list_panel">
          <div>
            <input type="text" placeholder="Сортировать с помощью общих выражений" oninput="img_fn_list_onregex()" id="img_fn_list_regex">
          </div>
          <div id="img_fn_list"></div>
        </div>

        <button onclick="toggle_reg_attr_panel()" class="leftsidebar_accordion" id="reg_attr_panel_button">Атрибуты области</button>
        <button onclick="toggle_file_attr_panel()" class="leftsidebar_accordion" id="file_attr_panel_button">атрибуты файла</button>

        <button class="leftsidebar_accordion">Горячие клавиши</button>
        <div class="leftsidebar_accordion_panel">
          <table style="padding: 2em 0em;">
            <tr>
              <td style="width: 6em;">n/p (&larr;/&rarr;)</td>
              <td>Следующее/предыдущее изображение</td>
            </tr>
            <tr>
              <td>+&nbsp;/&nbsp;-&nbsp;/&nbsp;=</td>
              <td>Увеличение/уменьшение масштаба/сброс</td>
            </tr>
            <tr>
              <td>Ctrl + c</td>
              <td>Копировать выбранные области</td>
            </tr>
            <tr>
              <td>Ctrl + v</td>
              <td>Вставить выбранные области</td>
            </tr>
            <tr>
              <td>Ctrl + a</td>
              <td>Выделить все области</td>
            </tr>
            <tr>
              <td>Del, Bkspc</td>
              <td>Удалить область с изображения</td>
            </tr>
            <tr>
              <td>Esc</td>
              <td>Отменить действие</td>
            </tr>
            <tr>
              <td>Ctrl + s</td>
              <td>Загрузить аннотации</td>
            </tr>
            <tr>
              <td>Пробел</td>
              <td>Переключение списка изображений</td>
            </tr>
          </table>
        </div>

      </div> <!-- конец левой боковой -->
      <div id="leftsidebar_collapse_panel">
        <div onclick="toggle_leftsidebar()" id="leftsidebar_collapse_button" title="Show/hide left toolbar">
          &ltrif;</div>
      </div>

      <!-- Основной сегмент: содержит изображение, ... -->
      <div id="display_area">
        <div id="canvas_panel">
          <canvas id="image_canvas"></canvas>
          <canvas id="region_canvas" tabindex="1">К сожалению, Ваш браузер не поддерживает функциональность HTML5 Canvas, которая требуется для этого приложения.</canvas>
        </div>

        <div>
          <div class="text_panel" id="start_info_panel">Начало работы с VKR ...</div>


          <div class="text_panel" id="getting_started_panel">
            <h1>Начало работы</h1>
            <ol>
              <li>Нажмите [Изображение > Загрузить или добавить изображения] в верхней строке меню, чтобы загрузить набор изображений, которые вы хотите прокомментировать.</li>
              <li>Нажмите n (или p) для навигации по загруженным изображениям. Вы также можете использовать значки &larr; и &rarr; на верхней панели инструментов для навигации.</li>
              <li>Нажмите <b>Атрибуты области</b> на левой панели, чтобы открыть панель внизу. Нажмите <b>[Добавить новый]</b>, чтобы добавить новый атрибут. Например:
                <pre>
                  имя_объекта
                  объект_цвет
                </pre>
                Вы можете добавить дополнительные атрибуты области в соответствии с вашими потребностями.
              <li>В разделе <b>Форма области</b> на левой панели щелкните прямоугольную форму</li>
              <li>Перемещая курсор мыши по области изображения, продолжайте нажимать правую кнопку мыши. При этом на изображении будет нарисована прямоугольная область.</li>
              <li>Эта вновь созданная область будет выбрана автоматически. Теперь вы можете ввести значение атрибута для этой области на нижней панели. 
                Вы можете прокомментировать несколько областей на этом или других изображениях и присвоить значение каждому предопределенному атрибуту.</li>
              <li>Чтобы загрузить аннотированные данные области, нажмите <b>[Аннотация > Сохранить как CSV]</b> в верхней строке меню. После этого будет загружен текстовый файл, содержащий данные о форме области и атрибутах.</li>
              <li>В следующий раз вы можете начать с левой стороны, сначала загрузив изображения, а затем импортировав CSV-файл (загруженный на шаге 7), нажав <b>[Аннотация > Импортировать]</b>.
            </li></ol>
          </div>
        </div>
      </div>
    </div>

    <!-- панель ввода области и атрибутов файла -->
    <div id="attributes_panel">
      <div id="attributes_panel_toolbar">
        <div onclick="toggle_attributes_input_panel()" class="attributes_panel_button">&times;</div>
      </div>
      <table id="attributes_panel_table"></table>
    </div>

    <!-- для отображения сообщений о состоянии -->
    <div id="message_panel"></div>

    <!-- это вертикальное пространство необходимо для того, 
      чтобы на полосе прокрутки отображались такие элементы, как сочетания клавиш, скрытые под панелью атрибутов -->
    <div style="width: 100%;" id="vertical_space"></div>


    <script type="text/javascript">
      //<!--AUTO_INSERT_VKR_JS_HERE-->
      /*

  This source code is organized in the following groups:

  - Data structure for annotations
  - Initialization routine
  - Handlers for top navigation bar
  - Local file uploaders
  - Data Importer
  - Data Exporter
  - Maintainers of user interface
  - Image click handlers
  - Canvas update routines
  - Region collision routines
  - Shortcut key handlers
  - Persistence of annotation data in browser cache (i.e. localStorage)
  - Handlers for attributes input panel (spreadsheet like user input panel)

*/

"use strict";

var VERSION      = '0.0.6';
var NAME         = 'Выпускной квал';
var SHORT_NAME   = 'VKR';
var REGION_SHAPE = { RECT:'rect',
                         CIRCLE:'circle',
                         ELLIPSE:'ellipse',
                         POLYGON:'polygon',
                         POINT:'point',
                         POLYLINE:'polyline'
                       };

var REGION_EDGE_TOL           = 20;   // pixel
var REGION_CONTROL_POINT_SIZE = 2;
var REGION_POINT_RADIUS       = 3;
var POLYGON_VERTEX_MATCH_TOL  = 5;
var REGION_MIN_DIM            = 3;
var MOUSE_CLICK_TOL          = 2;
var ELLIPSE_EDGE_TOL          = 0.2; // euclidean distance
var THETA_TOL                 = Math.PI/18; // 10 degrees
var POLYGON_RESIZE_VERTEX_OFFSET    = 100;
var CANVAS_DEFAULT_ZOOM_LEVEL_INDEX = 3;
var CANVAS_ZOOM_LEVELS = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0, 2.5, 3.0, 4, 5];

var THEME_REGION_BOUNDARY_WIDTH = 4;
var THEME_BOUNDARY_LINE_COLOR   = "#1a1a1a";
var THEME_BOUNDARY_FILL_COLOR   = "#aaeeff";
var THEME_SEL_REGION_FILL_COLOR = "#808080";
var THEME_SEL_REGION_FILL_BOUNDARY_COLOR = "#000000";
var THEME_SEL_REGION_OPACITY    = 0.5;
var THEME_MESSAGE_TIMEOUT_MS    = 6000;
var THEME_ATTRIBUTE_VALUE_FONT  = '10pt Sans';
var THEME_CONTROL_POINT_COLOR   = '#ff0000';

var CSV_SEP        = ',';
var CSV_QUOTE_CHAR = '"';
var CSV_KEYVAL_SEP = ':';
var IMPORT_CSV_COMMENT_CHAR = '#';

var _img_metadata = {};   // data structure to store loaded images metadata
var _img_count    = 0;    // count of the loaded images
var _canvas_regions = []; // image regions spec. in canvas space
var _canvas_scale   = 1.0;// current scale of canvas image

var _image_id_list  = []; // array of image id (in original order)
var _image_id       = ''; // id={filename+length} of current image
var _image_index    = -1; // index

var _current_image_filename;
var _current_image;
var _current_image_width;
var _current_image_height;

// image canvas
var _img_canvas = document.getElementById("image_canvas");
var _img_ctx    = _img_canvas.getContext("2d");
var _reg_canvas = document.getElementById("region_canvas");
var _reg_ctx    = _reg_canvas.getContext("2d");
var _canvas_width, _canvas_height;

// canvas zoom
var _canvas_zoom_level_index   = CANVAS_DEFAULT_ZOOM_LEVEL_INDEX; // 1.0
var _canvas_scale_without_zoom = 1.0;

// state of the application
var _is_user_drawing_region  = false;
var _current_image_loaded    = false;
var _is_window_resized       = false;
var _is_user_resizing_region = false;
var _is_user_moving_region   = false;
var _is_user_drawing_polygon = false;
var _is_region_selected      = false;
var _is_all_region_selected  = false;
var _is_user_updating_attribute_name  = false;
var _is_user_updating_attribute_value = false;
var _is_user_adding_attribute_name    = false;
var _is_loaded_img_list_visible  = false;
var _is_attributes_panel_visible = false;
var _is_reg_attr_panel_visible   = false;
var _is_file_attr_panel_visible  = false;
var _is_canvas_zoomed            = false;
var _is_loading_current_image    = false;
var _is_region_id_visible        = true;
var _is_region_boundary_visible  = true;
var _is_ctrl_pressed             = false;

// region
var _current_shape             = REGION_SHAPE.RECT;
var _current_polygon_region_id = -1;
var _user_sel_region_id        = -1;
var _click_x0 = 0; var _click_y0 = 0;
var _click_x1 = 0; var _click_y1 = 0;
var _region_click_x, _region_click_y;
var _copied_image_regions = [];
var _region_edge          = [-1, -1];
var _current_x = 0; var _current_y = 0;

// message
var _message_clear_timer;

// attributes
var _region_attributes             = {};
var _current_update_attribute_name = "";
var _current_update_region_id      = -1;
var _file_attributes               = {};
var _visible_attr_name             = '';

// persistence to local storage
var _is_local_storage_available = false;
var _is_save_ongoing = false;

// image list
var _reload_img_fn_list_table = true;
var _loaded_img_fn_list = [];
var _loaded_img_fn_list_file_index = [];
var _loaded_img_fn_list_table_html = [];


// UI html elements
var invisible_file_input = document.getElementById("invisible_file_input");
var display_area = document.getElementById("display_area");
var ui_top_panel = document.getElementById("ui_top_panel");
var canvas_panel = document.getElementById("canvas_panel");

var annotation_list_snippet = document.getElementById("annotation_list_snippet");
var annotation_textarea     = document.getElementById("annotation_textarea");

var img_fn_list_panel     = document.getElementById('img_fn_list_panel');
var img_fn_list           = document.getElementById('img_fn_list');
var attributes_panel      = document.getElementById('attributes_panel');
var annotation_data_window;

var BBOX_LINE_WIDTH       = 4;
var BBOX_SELECTED_OPACITY = 0.3;
var BBOX_BOUNDARY_FILL_COLOR_ANNOTATED = "#f2f2f2";
var BBOX_BOUNDARY_FILL_COLOR_NEW       = "#aaeeff";
var BBOX_BOUNDARY_LINE_COLOR           = "#1a1a1a";
var BBOX_SELECTED_FILL_COLOR           = "#ffffff";

//
// Data structure for annotations
//
function ImageMetadata(fileref, filename, size) {
  this.filename = filename;
  this.size     = size;
  this.fileref  = fileref;          // image url or local file ref.
  this.regions  = [];
  this.file_attributes = {};        // image attributes
  this.base64_img_data = '';        // image data stored as base 64
}

function ImageRegion() {
  this.is_user_selected  = false;
  this.shape_attributes  = {}; // region shape attributes
  this.region_attributes = {}; // region attributes
}

//
// Initialization routine
//
function _init() {
  console.log(NAME);
  show_message(NAME + ' (' + NAME + ') версии ' + VERSION +
               '. готова !', 2*THEME_MESSAGE_TIMEOUT_MS);
  show_home_panel();
  init_leftsidebar_accordion();

  _is_local_storage_available = check_local_storage();
  if (_is_local_storage_available) {
    if (is_data_in_localStorage()) {
      show_localStorage_recovery_options();
    }
  }

  // run attached sub-modules (if any)
  if (typeof _load_submodules === 'function') {
    setTimeout(function() {
      _load_submodules();
    }, 100);
  }
}

//
// Handlers for top navigation bar
//
function show_home_panel() {
  if (_current_image_loaded) {
    show_all_canvas();
    set_all_text_panel_display('none');
  } else {
    var start_info = '<p><a title="Load or Add Images" style="cursor: pointer; color: blue;" onclick="sel_local_images()">Load images</a> to start annotation or, see <a title="Getting started with VGG Image Annotator" style="cursor: pointer; color: blue;" onclick="show_getting_started_panel()">Getting Started</a>.</p>';
    clear_image_display_area();
    document.getElementById('start_info_panel').innerHTML = start_info;
    document.getElementById('start_info_panel').style.display = 'block';
  }
}
function sel_local_images() {
  // source: https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications
  if (invisible_file_input) {
    invisible_file_input.accept   = '.jpg,.jpeg,.png,.bmp';
    invisible_file_input.onchange = store_local_img_ref;
    invisible_file_input.click();
  }
}
function download_all_region_data(type) {
  // Javascript strings (DOMString) is automatically converted to utf-8
  // see: https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob
  var all_region_data = pack_metadata(type);
  var blob_attr = {type: 'text/'+type+';charset=utf-8'};
  var all_region_data_blob = new Blob(all_region_data, blob_attr);

  if ( all_region_data_blob.size > (2*1024*1024) &&
       type === 'csv' ) {
    show_message(' Размер файла CSV ' + (all_region_data_blob.size/(1024*1024)) +
                 ' МБ. Рекомендуется сохранить как JSON');
  } else {
    save_data_to_local_file(all_region_data_blob, 'region_data.'+type);
  }
}

function sel_local_data_file(type) {
  if (invisible_file_input) {
    invisible_file_input.accept='.csv,.json';
    switch(type) {
    case 'annotations':
      invisible_file_input.onchange = import_annotations_from_file;
      break;

    case 'attributes':
      invisible_file_input.onchange = import_attributes_from_file;
      break;

    default:
      return;
    }
    invisible_file_input.click();
  }
}
function import_attributes() {
  if (_current_image_loaded) {
    if (invisible_file_input) {
      invisible_file_input.accept   = '.csv,.json';
      invisible_file_input.onchange = import_region_attributes_from_file;
      invisible_file_input.click();
    }
  } else {
    show_message("Сначала загрузитьте изображения, пожалуйста");
  }
}
function show_about_panel() {
  set_all_text_panel_display('none');
  document.getElementById("about_panel").style.display = "block";
  canvas_panel.style.display = "none";
}
function show_getting_started_panel() {
  set_all_text_panel_display('none');
  document.getElementById("getting_started_panel").style.display = "block";
  canvas_panel.style.display = "none";
}
function show_license_panel() {
  set_all_text_panel_display('none');
  document.getElementById("license_panel").style.display = 'block';
  canvas_panel.style.display = "none";
}
function set_all_text_panel_display(style_display) {
  var tp = document.getElementsByClassName('text_panel');
  for ( var i = 0; i < tp.length; ++i ) {
    tp[i].style.display = style_display;
  }
}
function clear_image_display_area() {
  hide_all_canvas();
  set_all_text_panel_display('none');
}

//
// Local file uploaders
//
function store_local_img_ref(event) {
  var user_selected_images = event.target.files;
  var original_image_count = _img_count;

  // clear browser cache if user chooses to load new images
  if (original_image_count === 0) {
    remove_data_from_localStorage();
  }

  var discarded_file_count = 0;
  for ( var i = 0; i < user_selected_images.length; ++i ) {
    var filetype = user_selected_images[i].type.substr(0, 5);
    if ( filetype === 'image' ) {
      var filename = user_selected_images[i].name;
      var size     = user_selected_images[i].size;
      var img_id   = _get_image_id(filename, size);

      if ( _img_metadata.hasOwnProperty(img_id) ) {
        if ( _img_metadata[img_id].fileref ) {
          show_message('Изображение ' + filename + ' уже загружено. Пропускаем!');
        } else {
          _img_metadata[img_id].fileref = user_selected_images[i];
          show_message('Области уже есть для файла ' + filename + ' !');
        }
      } else {
        _img_metadata[img_id] = new ImageMetadata(user_selected_images[i],
                                                      filename,
                                                      size);
        _image_id_list.push(img_id);
        _loaded_img_fn_list.push(filename);
        _img_count += 1;
        _reload_img_fn_list_table = true;
      }
    } else {
      discarded_file_count += 1;
    }
  }

  if ( _img_metadata ) {
    var status_msg = 'Загрузка ' + (_img_count - original_image_count) + ' изображений.';
    if ( discarded_file_count ) {
      status_msg += ' ( Сброшено ' + discarded_file_count + ' неверных файлов! )';
    }
    show_message(status_msg);

    if ( _image_index === -1 ) {
      show_image(0);
    } else {
      show_image( original_image_count );
    }
    update_img_fn_list();
  } else {
    show_message("Сначала загрузитьте изображения, пожалуйста");
  }
}

//
// Data Importer
//

function import_region_attributes_from_file(event) {
  var selected_files = event.target.files;
  for ( var i=0 ; i < selected_files.length; ++i ) {
    var file = selected_files[i];
    switch(file.type) {
    case 'text/csv':
      load_text_file(file, import_region_attributes_from_csv);
      break;

    default:
      show_message('Аттрибуты областей не могут быть загружены из файла ' + file.type);
      break;
    }
  }
}

function import_region_attributes_from_csv(data) {
  data = data.replace(/\n/g, ''); // discard newline \n
  var csvdata = data.split(',');
  var attributes_import_count = 0;
  for ( var i = 0; i < csvdata.length; ++i ) {
    if ( !_region_attributes.hasOwnProperty(csvdata[i]) ) {
      _region_attributes[csvdata[i]] = true;
      attributes_import_count += 1;
    }
  }

  _reload_img_fn_list_table = true;
  show_message('Импортировано ' + attributes_import_count + ' аттрибутов из файла CSV');
  save_current_data_to_browser_cache();
}

function import_annotations_from_file(event) {
  var selected_files = event.target.files;
  for ( var i = 0; i < selected_files.length; ++i ) {
    var file = selected_files[i];
    switch(file.type) {
    case '': // Fall-through // Windows 10: Firefox и Chrome не отправлят тип файла
      show_message('Тип файла ' + file.name + ' не может быть определен! Допустим текст!.');
    case 'text/plain': // Fall-through
    case 'application/vnd.ms-excel': // Fall-through 
    case 'text/csv':
      load_text_file(file, import_annotations_from_csv);
      break;

    case 'text/json': // Fall-through
    case 'application/json':
      load_text_file(file, import_annotations_from_json);
      break;

    default:
      show_message('Аннотации не могут быть импортированы из файла ' + file.type);
      break;
    }
  }
}
function import_annotations_from_csv(data) {
  if ( data === '' || typeof(data) === 'undefined') {
    return;
  }

  // csv header format
  // #filename,file_size,file_attributes,region_count,region_id,region_shape_attributes,region_attributes
  var filename_index = 0;
  var size_index = 1;
  var file_attr_index = 2;
  var region_shape_attr_index = 5;
  var region_attr_index = 6;
  var csv_column_count = 7;

  var region_import_count = 0;
  var malformed_csv_lines_count = 0;

  var line_split_regex = new RegExp('\n|\r|\r\n', 'g');
  var csvdata = data.split(line_split_regex);

  for ( var i=0; i < csvdata.length; ++i ) {
    // ignore blank lines
    if (csvdata[i].charAt(0) === '\n' || csvdata[i].charAt(0) === '') {
      continue;
    }

    if (csvdata[i].charAt(0) === IMPORT_CSV_COMMENT_CHAR) {
      // parse header
      var h = csvdata[i].substring(1, csvdata[i].length); // remove #
      h = h.split(',');
      for ( var j = 0; j < h.length; ++j ) {
        switch ( h[j] ) {
        case 'filename':
          filename_index = j;
          break;

        case 'file_size':
          size_index = j;
          break;

        case 'file_attributes':
          file_attr_index = j;
          break;

        case 'region_shape_attributes':
          region_shape_attr_index = j;
          break;

        case 'region_attributes':
          region_attr_index = j;
          break;
        }
      }
      csv_column_count = h.length;
    } else {
      var d = parse_csv_line(csvdata[i]);

      // check if csv line was malformed
      if ( d.length !== csv_column_count ) {
        malformed_csv_lines_count += 1;
        continue;
      }

      var filename = d[filename_index];
      var size     = d[size_index];
      var image_id = _get_image_id(filename, size);

      if ( _img_metadata.hasOwnProperty(image_id) ) {
        // copy file attributes
        if ( d[file_attr_index] !== '"{}"') {
          var fattr = d[file_attr_index];
          fattr     = remove_prefix_suffix_quotes( fattr );
          fattr     = unescape_from_csv( fattr );

          var m = json_str_to_map( fattr );
          for( var key in m ) {
            _img_metadata[image_id].file_attributes[key] = m[key];

            if (!_file_attributes.hasOwnProperty(key)) {
              _file_attributes[key] = true;
            }
          }
        }

        var region_i = new ImageRegion();
        // copy regions shape attributes
        if ( d[region_shape_attr_index] !== '"{}"' ) {
          var sattr = d[region_shape_attr_index];
          sattr     = remove_prefix_suffix_quotes( sattr );
          sattr     = unescape_from_csv( sattr );

          var m = json_str_to_map( sattr );
          for ( var key in m ) {
            region_i.shape_attributes[key] = m[key];
          }
        }

        // copy region attributes
        if ( d[region_attr_index] !== '"{}"' ) {
          var rattr = d[region_attr_index];
          rattr     = remove_prefix_suffix_quotes( rattr );
          rattr     = unescape_from_csv( rattr );

          var m = json_str_to_map( rattr );
          for ( var key in m ) {
            region_i.region_attributes[key] = m[key];

            if (!_region_attributes.hasOwnProperty(key)) {
              _region_attributes[key] = true;
            }
          }
        }

        // add regions only if they are present
        if (Object.keys(region_i.shape_attributes).length > 0 ||
            Object.keys(region_i.region_attributes).length > 0 ) {
              _img_metadata[image_id].regions.push(region_i);
          region_import_count += 1;
        }
      }
    }
  }
  show_message('Импорт: [' + region_import_count + '] регионов, ' +
               '[' + malformed_csv_lines_count  + '] испорченных строк CSV.');

               _reload_img_fn_list_table = true;
  show_image(_image_index);
  save_current_data_to_browser_cache();
}

function import_annotations_from_json(data) {
  if (data === '' || typeof(data) === 'undefined') {
    return;
  }

  var d = JSON.parse(data);

  var region_import_count = 0;
  for (var image_id in d) {
    if ( _img_metadata.hasOwnProperty(image_id) ) {

      // copy image attributes
      for (var key in d[image_id].file_attributes) {
        if ( !_img_metadata[image_id].file_attributes[key] ) {
          _img_metadata[image_id].file_attributes[key] = d[image_id].file_attributes[key];
        }
        if ( !_file_attributes.hasOwnProperty(key) ) {
          _file_attributes[key] = true;
        }
      }

      // copy regions
      var regions = d[image_id].regions;
      for ( var i in regions ) {
        var region_i = new ImageRegion();
        for ( var key in regions[i].shape_attributes ) {
          region_i.shape_attributes[key] = regions[i].shape_attributes[key];
        }
        for ( var key in regions[i].region_attributes ) {
          region_i.region_attributes[key] = regions[i].region_attributes[key];

          if ( !_region_attributes.hasOwnProperty(key) ) {
            _region_attributes[key] = true;
          }
        }

        // add regions only if they are present
        if ( Object.keys(region_i.shape_attributes).length > 0 ||
             Object.keys(region_i.region_attributes).length > 0 ) {
              _img_metadata[image_id].regions.push(region_i);
          region_import_count += 1;
        }
      }
    }
  }
  show_message('Импорт: [' + region_import_count + '] регионов');

  _reload_img_fn_list_table = true;
  show_image(_image_index);
}

// предполагается, что csv соответствует стандарту RFC 4180
// see: https://en.wikipedia.org/wiki/Comma-separated_values
function parse_csv_line(s, field_separator) {
  if (typeof(s) === 'undefined' || s.length === 0 ) {
    return [];
  }

  if (typeof(field_separator) === 'undefined') {
    field_separator = ',';
  }
  var double_quote_seen = false;
  var start = 0;
  var d = [];

  var i = 0;
  while ( i < s.length) {
    if (s.charAt(i) === field_separator) {
      if (double_quote_seen) {
        // field separator inside double quote is ignored
        i = i + 1;
      } else {
        //var part = s.substr(start, i - start);
        d.push( s.substr(start, i - start) );
        start = i + 1;
        i = i + 1;
      }
    } else {
      if (s.charAt(i) === '"') {
        if (double_quote_seen) {
          if (s.charAt(i+1) === '"') {
            // ignore escaped double quotes
            i = i + 2;
          } else {
            // closing of double quote
            double_quote_seen = false;
            i = i + 1;
          }
        } else {
          double_quote_seen = true;
          start = i;
          i = i + 1;
        }
      } else {
        i = i + 1;
      }
    }

  }
  // extract the last field (csv rows have no trailing comma)
  d.push( s.substr(start) );
  return d;
}

// s = '{"name":"rect","x":188,"y":90,"width":243,"height":233}'
function json_str_to_map(s) {
  if (typeof(s) === 'undefined' || s.length === 0 ) {
    return {};
  }

  return JSON.parse(s);
}

// ensure the exported json string conforms to RFC 4180
// see: https://en.wikipedia.org/wiki/Comma-separated_values
function map_to_json(m) {
  var s = [];
  for ( var key in m ) {
    var v   = m[key];
    var si  = JSON.stringify(key);
    si += CSV_KEYVAL_SEP;
    si += JSON.stringify(v);
    s.push( si );
  }
  return '{' + s.join(CSV_SEP) + '}';
}

function escape_for_csv(s) {
  return s.replace(/["]/g, '""');
}

function unescape_from_csv(s) {
  return s.replace(/""/g, '"');
}

function remove_prefix_suffix_quotes(s) {
  if ( s.charAt(0) === '"' && s.charAt(s.length-1) === '"' ) {
    return s.substr(1, s.length-2);
  } else {
    return s;
  }
}

function clone_image_region(r0) {
  var r1 = new ImageRegion();
  r1.is_user_selected = r0.is_user_selected;

  // copy shape attributes
  for ( var key in r0.shape_attributes ) {
    r1.shape_attributes[key] = clone_value(r0.shape_attributes[key]);
  }

  // copy region attributes
  for ( var key in r0.region_attributes ) {
    r1.region_attributes[key] = clone_value(r0.region_attributes[key]);
  }
  return r1;
}

function clone_value(value) {
  if ( typeof(value) === 'object' ) {
    if ( Array.isArray(value) ) {
      return value.slice(0);
    } else {
      var copy = {};
      for ( var p in value ) {
        if ( value.hasOwnProperty(p) ) {
          copy[p] = clone_value(value[p]);
        }
      }
      return copy;
    }
  }
  return value;
}

function _get_image_id(filename, size) {
  if ( typeof(size) === 'undefined' ) {
    return filename;
  } else {
    return filename + size;
  }
}

function load_text_file(text_file, callback_function) {
  if (text_file) {
    var text_reader = new FileReader();
    text_reader.addEventListener( 'progress', function(e) {
      show_message('Загрузка данных из текстового файла : ' + text_file.name + ' ... ');
    }, false);

    text_reader.addEventListener( 'error', function() {
      show_message('Онибка в агрузке данных из текстового файла :  ' + text_file.name + ' !');
      callback_function('');
    }, false);

    text_reader.addEventListener( 'load', function() {
      callback_function(text_reader.result);
    }, false);
    text_reader.readAsText(text_file, 'utf-8');
  }
}

//
// Data Exporter
//
function pack_metadata(return_type) {
  if( return_type === 'csv' ) {
    var csvdata = [];
    var csvheader = '#filename,file_size,file_attributes,region_count,region_id,region_shape_attributes,region_attributes';
    csvdata.push(csvheader);

    for ( var image_id in _img_metadata ) {
      var fattr = map_to_json( _img_metadata[image_id].file_attributes );
      fattr = escape_for_csv( fattr );

      var prefix = '\n' + _img_metadata[image_id].filename;
      prefix += ',' + _img_metadata[image_id].size;
      prefix += ',"' + fattr + '"';

      var r = _img_metadata[image_id].regions;

      if ( r.length !==0 ) {
        for ( var i = 0; i < r.length; ++i ) {
          var csvline = [];
          csvline.push(prefix);
          csvline.push(r.length);
          csvline.push(i);

          var sattr = map_to_json( r[i].shape_attributes );
          sattr = '"' +  escape_for_csv( sattr ) + '"';
          csvline.push(sattr);

          var rattr = map_to_json( r[i].region_attributes );
          rattr = '"' +  escape_for_csv( rattr ) + '"';
          csvline.push(rattr);
          csvdata.push( csvline.join(CSV_SEP) );
        }
      } else {
        // @todo: reconsider this practice of adding an empty entry
        csvdata.push(prefix + ',0,0,"{}","{}"');
      }
    }
    return csvdata;
  } else {
    // JSON.stringify() does not work with Map()
    // hence, we cast everything as objects
    var _img_metadata_as_obj = {};
    for ( var image_id in _img_metadata ) {
      var image_data = {};
      //image_data.fileref = _img_metadata[image_id].fileref;
      image_data.fileref = '';
      image_data.size = _img_metadata[image_id].size;
      image_data.filename = _img_metadata[image_id].filename;
      image_data.base64_img_data = '';
      //image_data.base64_img_data = _img_metadata[image_id].base64_img_data;

      // copy file attributes
      image_data.file_attributes = {};
      for ( var key in _img_metadata[image_id].file_attributes ) {
        image_data.file_attributes[key] = _img_metadata[image_id].file_attributes[key];
      }

      // copy all region shape_attributes
      image_data.regions = {};
      for ( var i = 0; i < _img_metadata[image_id].regions.length; ++i ) {
        image_data.regions[i] = {};
        image_data.regions[i].shape_attributes = {};
        image_data.regions[i].region_attributes = {};
        // copy region shape_attributes
        for ( var key in _img_metadata[image_id].regions[i].shape_attributes ) {
          image_data.regions[i].shape_attributes[key] = _img_metadata[image_id].regions[i].shape_attributes[key];
        }
        // copy region_attributes
        for ( var key in _img_metadata[image_id].regions[i].region_attributes ) {
          image_data.regions[i].region_attributes[key] = _img_metadata[image_id].regions[i].region_attributes[key];
        }
      }
      _img_metadata_as_obj[image_id] = image_data;
    }
    return [JSON.stringify(_img_metadata_as_obj)];
  }
}

function save_data_to_local_file(data, filename) {
  var a      = document.createElement('a');
  a.href     = URL.createObjectURL(data);
  a.target   = '_blank';
  a.download = filename;

  // simulate a mouse click event
  var event = new MouseEvent('click', {
    view: window,
    bubbles: true,
    cancelable: true
  });

  a.dispatchEvent(event);
}

//
// Maintainers of user interface
//

function show_message(msg, t) {
  if ( _message_clear_timer ) {
    clearTimeout(_message_clear_timer); // stop any previous timeouts
  }
  var timeout = t;
  if ( typeof t === 'undefined' ) {
    timeout = THEME_MESSAGE_TIMEOUT_MS;
  }
  document.getElementById('message_panel').innerHTML = msg;
  _message_clear_timer = setTimeout( function() {
    document.getElementById('message_panel').innerHTML = ' ';
  }, timeout);
}

function show_image(image_index) {
  if (_is_loading_current_image) {
    return;
  }

  var img_id = _image_id_list[image_index];
  if ( !_img_metadata.hasOwnProperty(img_id)) {
    return;
  }

  var img_filename = _img_metadata[img_id].filename;
  var img_reader = new FileReader();
  _is_loading_current_image = true;

  img_reader.addEventListener( "loadstart", function(e) {
    img_loading_spinbar(true);
  }, false);

  img_reader.addEventListener( "progress", function(e) {
  }, false);

  img_reader.addEventListener( "error", function() {
    _is_loading_current_image = false;
    img_loading_spinbar(false);
    show_message("Ошибка при загрузке изображения " + img_filename + " !");
  }, false);

  img_reader.addEventListener( "abort", function() {
    _is_loading_current_image = false;
    img_loading_spinbar(false);
    show_message("Прервана загрузка изображения" + img_filename + " !");
  }, false);

  img_reader.addEventListener( "load", function() {
    _current_image = new Image();

    _current_image.addEventListener( "error", function() {
      _is_loading_current_image = false;
      img_loading_spinbar(false);
      show_message("Ошибка при загрузке изображения " + img_filename + " !");
    }, false);

    _current_image.addEventListener( "abort", function() {
      _is_loading_current_image = false;
      img_loading_spinbar(false);
      show_message("Прервана загрузка изображения " + img_filename + " !");
    }, false);

    _current_image.addEventListener( "load", function() {

      // update the current state of application
      _image_id = img_id;
      _image_index = image_index;
      _current_image_filename = img_filename;
      _current_image_loaded = true;
      _is_loading_current_image = false;
      _click_x0 = 0; _click_y0 = 0;
      _click_x1 = 0; _click_y1 = 0;
      _is_user_drawing_region = false;
      _is_window_resized = false;
      _is_user_resizing_region = false;
      _is_user_moving_region = false;
      _is_user_drawing_polygon = false;
      _is_region_selected = false;
      _user_sel_region_id = -1;
      _current_image_width = _current_image.naturalWidth;
      _current_image_height = _current_image.naturalHeight;

      // set the size of canvas
      // based on the current dimension of browser window
      var de = document.documentElement;
      var canvas_panel_width = de.clientWidth - 230;
      var canvas_panel_height = de.clientHeight - 2*ui_top_panel.offsetHeight;
      _canvas_width = _current_image_width;
      _canvas_height = _current_image_height;
      if ( _canvas_width > canvas_panel_width ) {
        // resize image to match the panel width
        var scale_width = canvas_panel_width / _current_image.naturalWidth;
        _canvas_width = canvas_panel_width;
        _canvas_height = _current_image.naturalHeight * scale_width;
      }
      if ( _canvas_height > canvas_panel_height ) {
        // resize further image if its height is larger than the image panel
        var scale_height = canvas_panel_height / _canvas_height;
        _canvas_height = canvas_panel_height;
        _canvas_width = _canvas_width * scale_height;
      }
      _canvas_width = Math.round(_canvas_width);
      _canvas_height = Math.round(_canvas_height);
      _canvas_scale = _current_image.naturalWidth / _canvas_width;
      _canvas_scale = _canvas_scale;
      set_all_canvas_size(_canvas_width, _canvas_height);
      //set_all_canvas_scale(_canvas_scale_without_zoom);

      // ensure that all the canvas are visible
      clear_image_display_area();
      show_all_canvas();

      // we only need to draw the image once in the image_canvas
      _img_ctx.clearRect(0, 0, _canvas_width, _canvas_height);
      _img_ctx.drawImage(_current_image, 0, 0,
                             _canvas_width, _canvas_height);

      // refresh the attributes panel
      //update_attributes_panel();

      _load_canvas_regions(); // image to canvas space transform
      _redraw_reg_canvas();
      _reg_canvas.focus();

      img_loading_spinbar(false);

      // refresh the image list
      _reload_img_fn_list_table = true;
      update_img_fn_list();
    });
    _current_image.src = img_reader.result;
  }, false);

  if (_img_metadata[img_id].base64_img_data === '') {
    // load image from file
    img_reader.readAsDataURL( _img_metadata[img_id].fileref );
  } else {
    // load image from base64 data or URL
    img_reader.readAsText( new Blob([_img_metadata[img_id].base64_img_data]) );
  }
}

// transform regions in image space to canvas space
function _load_canvas_regions() {
  // load all existing annotations into _canvas_regions
  var regions = _img_metadata[_image_id].regions;
  _canvas_regions  = [];
  for ( var i = 0; i < regions.length; ++i ) {
    var region_i = new ImageRegion();
    for ( var key in regions[i].shape_attributes ) {
      region_i.shape_attributes[key] = regions[i].shape_attributes[key];
    }
    _canvas_regions.push(region_i);

    switch(_canvas_regions[i].shape_attributes['name']) {
    case REGION_SHAPE.RECT:
      var x      = regions[i].shape_attributes['x'] / _canvas_scale;
      var y      = regions[i].shape_attributes['y'] / _canvas_scale;
      var width  = regions[i].shape_attributes['width']  / _canvas_scale;
      var height = regions[i].shape_attributes['height'] / _canvas_scale;

      _canvas_regions[i].shape_attributes['x'] = Math.round(x);
      _canvas_regions[i].shape_attributes['y'] = Math.round(y);
      _canvas_regions[i].shape_attributes['width'] = Math.round(width);
      _canvas_regions[i].shape_attributes['height'] = Math.round(height);
      break;

    case REGION_SHAPE.CIRCLE:
      var cx = regions[i].shape_attributes['cx'] / _canvas_scale;
      var cy = regions[i].shape_attributes['cy'] / _canvas_scale;
      var r  = regions[i].shape_attributes['r']  / _canvas_scale;
      _canvas_regions[i].shape_attributes['cx'] = Math.round(cx);
      _canvas_regions[i].shape_attributes['cy'] = Math.round(cy);
      _canvas_regions[i].shape_attributes['r'] = Math.round(r);
      break;

    case REGION_SHAPE.ELLIPSE:
      var cx = regions[i].shape_attributes['cx'] / _canvas_scale;
      var cy = regions[i].shape_attributes['cy'] / _canvas_scale;
      var rx = regions[i].shape_attributes['rx'] / _canvas_scale;
      var ry = regions[i].shape_attributes['ry'] / _canvas_scale;
      _canvas_regions[i].shape_attributes['cx'] = Math.round(cx);
      _canvas_regions[i].shape_attributes['cy'] = Math.round(cy);
      _canvas_regions[i].shape_attributes['rx'] = Math.round(rx);
      _canvas_regions[i].shape_attributes['ry'] = Math.round(ry);
      break;

    case REGION_SHAPE.POLYGON:
      var all_points_x = regions[i].shape_attributes['all_points_x'].slice(0);
      var all_points_y = regions[i].shape_attributes['all_points_y'].slice(0);
      for (var j=0; j<all_points_x.length; ++j) {
        all_points_x[j] = Math.round(all_points_x[j] / _canvas_scale);
        all_points_y[j] = Math.round(all_points_y[j] / _canvas_scale);
      }
      _canvas_regions[i].shape_attributes['all_points_x'] = all_points_x;
      _canvas_regions[i].shape_attributes['all_points_y'] = all_points_y;
      break;

    case REGION_SHAPE.POINT:
      var cx = regions[i].shape_attributes['cx'] / _canvas_scale;
      var cy = regions[i].shape_attributes['cy'] / _canvas_scale;

      _canvas_regions[i].shape_attributes['cx'] = Math.round(cx);
      _canvas_regions[i].shape_attributes['cy'] = Math.round(cy);
      break;
    }
  }
}

// updates currently selected region shape
function select_region_shape(sel_shape_name) {
  for ( var shape_name in REGION_SHAPE ) {
    var ui_element = document.getElementById('region_shape_' + REGION_SHAPE[shape_name]);
    ui_element.classList.remove('selected');
  }

  _current_shape = sel_shape_name;
  var ui_element = document.getElementById('region_shape_' + _current_shape);
  ui_element.classList.add('selected');

  switch(_current_shape) {
  case REGION_SHAPE.RECT: // Fall-through
  case REGION_SHAPE.CIRCLE: // Fall-through
  case REGION_SHAPE.ELLIPSE:
    show_message('Один один клик и перетащите курсор мыши, чтобы выделить ' +
    _current_shape + ' область');
    break;

  case REGION_SHAPE.POLYLINE:
  case REGION_SHAPE.POLYGON:
    _is_user_drawing_polygon = false;
    _current_polygon_region_id = -1;

    show_message('[Enter] для завершения, [Esc] для отмены, ' +
                 '[Клик] для определения вершин ломанных фигуры/линии')
    break;

  case REGION_SHAPE.POINT:
    show_message('Нажмите одним щелчком мыши, чтобы определить точки (или метки)');
    break;

  default:
    show_message('Выбрана неизвестная форма!');
    break;
  }
}

function set_all_canvas_size(w, h) {
  _img_canvas.height = h;
  _img_canvas.width  = w;

  _reg_canvas.height = h;
  _reg_canvas.width = w;

  canvas_panel.style.height = h + 'px';
  canvas_panel.style.width  = w + 'px';
}

function set_all_canvas_scale(s) {
  _img_ctx.scale(s, s);
  _reg_ctx.scale(s, s);
}

function show_all_canvas() {
  canvas_panel.style.display = 'inline-block';
}

function hide_all_canvas() {
  canvas_panel.style.display = 'none';
}

function jump_to_image(image_index) {
  if ( _img_count <= 0 ) {
    return;
  }

  // reset zoom
  if ( _is_canvas_zoomed ) {
    _is_canvas_zoomed = false;
    _canvas_zoom_level_index = CANVAS_DEFAULT_ZOOM_LEVEL_INDEX;
    var zoom_scale = CANVAS_ZOOM_LEVELS[_canvas_zoom_level_index];
    set_all_canvas_scale(zoom_scale);
    set_all_canvas_size(_canvas_width, _canvas_height);
    _canvas_scale = _canvas_scale_without_zoom;
  }

  if ( image_index >= 0 && image_index < _img_count) {
    show_image(image_index);
  }
}

function count_missing_region_attr(img_id) {
  var miss_region_attr_count = 0;
  var attr_count = Object.keys(_region_attributes).length;
  for( var i=0; i < _img_metadata[img_id].regions.length; ++i ) {
    var set_attr_count = Object.keys(_img_metadata[img_id].regions[i].region_attributes).length;
    miss_region_attr_count += ( attr_count - set_attr_count );
  }
  return miss_region_attr_count;
}

function count_missing_file_attr(img_id) {
  return Object.keys(_file_attributes).length - Object.keys(_img_metadata[img_id].file_attributes).length;
}

function toggle_all_regions_selection(is_selected) {
  for (var i=0; i<_canvas_regions.length; ++i) {
    _canvas_regions[i].is_user_selected = is_selected;
    _img_metadata[_image_id].regions[i].is_user_selected = is_selected;
  }
  _is_all_region_selected = is_selected;
}
function select_only_region(region_id) {
  toggle_all_regions_selection(false);
  set_region_select_state(region_id, true);
  _is_region_selected = true;
  _user_sel_region_id = region_id;
}
function set_region_select_state(region_id, is_selected) {
  _canvas_regions[region_id].is_user_selected = is_selected;
  _img_metadata[_image_id].regions[region_id].is_user_selected = is_selected;
}

function show_annotation_data() {
  var hstr = '<pre>' + pack_metadata('csv').join('') + '</pre>';
  if ( typeof annotation_data_window === 'undefined' ) {
    var window_features = 'toolbar=no,menubar=no,location=no,resizable=yes,scrollbars=yes,status=no';
    window_features += ',width=800,height=600';
    annotation_data_window = window.open('', 'Image Metadata ', window_features);
  }
  annotation_data_window.document.body.innerHTML = hstr;
}

//
// Image click handlers
//

// enter annotation mode on double click
_reg_canvas.addEventListener('dblclick', function(e) {
  _click_x0 = e.offsetX; _click_y0 = e.offsetY;
  var region_id = is_inside_region(_click_x0, _click_y0);

  if (region_id !== -1) {
    // user clicked inside a region, show attribute panel
    if(!_is_reg_attr_panel_visible) {
      toggle_reg_attr_panel();
    }
  }

}, false);

// user clicks on the canvas
_reg_canvas.addEventListener('mousedown', function(e) {
  _click_x0 = e.offsetX; _click_y0 = e.offsetY;
  _region_edge = is_on_region_corner(_click_x0, _click_y0);
  var region_id = is_inside_region(_click_x0, _click_y0);

  if ( _is_region_selected ) {
    // check if user clicked on the region boundary
    if ( _region_edge[1] > 0 ) {
      if ( !_is_user_resizing_region ) {
        // resize region
        if ( _region_edge[0] !== _user_sel_region_id ) {
          _user_sel_region_id = _region_edge[0];
        }
        _is_user_resizing_region = true;
      }
    } else {
      var yes = is_inside_this_region(_click_x0,
                                      _click_y0,
                                      _user_sel_region_id);
      if (yes) {
        if( !_is_user_moving_region ) {
          _is_user_moving_region = true;
          _region_click_x = _click_x0;
          _region_click_y = _click_y0;
        }
      }
      if ( region_id === -1 ) {
        // mousedown on outside any region
        _is_user_drawing_region = true;
        // unselect all regions
        _is_region_selected = false;
        _user_sel_region_id = -1;
        toggle_all_regions_selection(false);
      }
    }
  } else {
    if ( region_id === -1 ) {
      // mousedown outside a region
      if (_current_shape !== REGION_SHAPE.POLYGON &&
        _current_shape !== REGION_SHAPE.POLYLINE &&
          _current_shape !== REGION_SHAPE.POINT) {
        // this is a bounding box drawing event
        _is_user_drawing_region = true;
      }
    } else {
      // mousedown inside a region
      // this could lead to (1) region selection or (2) region drawing
      _is_user_drawing_region = true;
    }
  }
  e.preventDefault();
}, false);

// implements the following functionalities:
//  - new region drawing (including polygon)
//  - moving/resizing/select/unselect existing region
_reg_canvas.addEventListener('mouseup', function(e) {
  _click_x1 = e.offsetX; _click_y1 = e.offsetY;

  var click_dx = Math.abs(_click_x1 - _click_x0);
  var click_dy = Math.abs(_click_y1 - _click_y0);

  // indicates that user has finished moving a region
  if ( _is_user_moving_region ) {
    _is_user_moving_region = false;
    _reg_canvas.style.cursor = "default";

    var move_x = Math.round(_click_x1 - _region_click_x);
    var move_y = Math.round(_click_y1 - _region_click_y);

    if (Math.abs(move_x) > MOUSE_CLICK_TOL||
        Math.abs(move_y) > MOUSE_CLICK_TOL) {

      var image_attr = _img_metadata[_image_id].regions[_user_sel_region_id].shape_attributes;
      var canvas_attr = _canvas_regions[_user_sel_region_id].shape_attributes;

      switch( canvas_attr['name'] ) {
      case REGION_SHAPE.RECT:
        var xnew = image_attr['x'] + Math.round(move_x * _canvas_scale);
        var ynew = image_attr['y'] + Math.round(move_y * _canvas_scale);
        image_attr['x'] = xnew;
        image_attr['y'] = ynew;

        canvas_attr['x'] = Math.round( image_attr['x'] / _canvas_scale);
        canvas_attr['y'] = Math.round( image_attr['y'] / _canvas_scale);
        break;

      case REGION_SHAPE.CIRCLE: // Fall-through
      case REGION_SHAPE.ELLIPSE: // Fall-through
      case REGION_SHAPE.POINT:
        var cxnew = image_attr['cx'] + Math.round(move_x * _canvas_scale);
        var cynew = image_attr['cy'] + Math.round(move_y * _canvas_scale);
        image_attr['cx'] = cxnew;
        image_attr['cy'] = cynew;

        canvas_attr['cx'] = Math.round( image_attr['cx'] / _canvas_scale);
        canvas_attr['cy'] = Math.round( image_attr['cy'] / _canvas_scale);
        break;

      case REGION_SHAPE.POLYLINE: // handled by polygon
      case REGION_SHAPE.POLYGON:
        var img_px = image_attr['all_points_x'];
        var img_py = image_attr['all_points_y'];
        for (var i=0; i<img_px.length; ++i) {
          img_px[i] = img_px[i] + Math.round(move_x * _canvas_scale);
          img_py[i] = img_py[i] + Math.round(move_y * _canvas_scale);
        }

        var canvas_px = canvas_attr['all_points_x'];
        var canvas_py = canvas_attr['all_points_y'];
        for (var i=0; i<canvas_px.length; ++i) {
          canvas_px[i] = Math.round( img_px[i] / _canvas_scale );
          canvas_py[i] = Math.round( img_py[i] / _canvas_scale );
        }
        break;
      }
    } else {
      // indicates a user click on an already selected region
      // this could indicate a user's intention to select another
      // nested region within this region

      // traverse the canvas regions in alternating ascending
      // and descending order to solve the issue of nested regions
      var nested_region_id = is_inside_region(_click_x0, _click_y0, true);
      if (nested_region_id >= 0 &&
          nested_region_id !== _user_sel_region_id) {
            _user_sel_region_id = nested_region_id;
        _is_region_selected = true;
        _is_user_moving_region = false;

        // de-select all other regions if the user has not pressed Shift
        if ( !e.shiftKey ) {
          toggle_all_regions_selection(false);
        }
        set_region_select_state(nested_region_id, true);
        update_attributes_panel();
      }
    }
    _redraw_reg_canvas();
    _reg_canvas.focus();
    save_current_data_to_browser_cache();
    return;
  }

  // indicates that user has finished resizing a region
  if ( _is_user_resizing_region ) {
    // _click(x0,y0) to _click(x1,y1)
    _is_user_resizing_region = false;
    _reg_canvas.style.cursor = "default";

    // update the region
    var region_id = _region_edge[0];
    var image_attr = _img_metadata[_image_id].regions[region_id].shape_attributes;
    var canvas_attr = _canvas_regions[region_id].shape_attributes;

    switch (canvas_attr['name']) {
    case REGION_SHAPE.RECT:
      var d = [canvas_attr['x'], canvas_attr['y'], 0, 0];
      d[2] = d[0] + canvas_attr['width'];
      d[3] = d[1] + canvas_attr['height'];

      var mx = _current_x;
      var my = _current_y;
      var preserve_aspect_ratio = false;

      // constrain (mx,my) to lie on a line connecting a diagonal of rectangle
      if ( _is_ctrl_pressed ) {
        preserve_aspect_ratio = true;
      }

      rect_update_corner(_region_edge[1], d, mx, my, preserve_aspect_ratio);
      rect_standardize_coordinates(d);

      var w = Math.abs(d[2] - d[0]);
      var h = Math.abs(d[3] - d[1]);

      image_attr['x'] = Math.round(d[0] * _canvas_scale);
      image_attr['y'] = Math.round(d[1] * _canvas_scale);
      image_attr['width'] = Math.round(w * _canvas_scale);
      image_attr['height'] = Math.round(h * _canvas_scale);

      canvas_attr['x'] = Math.round( image_attr['x'] / _canvas_scale);
      canvas_attr['y'] = Math.round( image_attr['y'] / _canvas_scale);
      canvas_attr['width'] = Math.round( image_attr['width'] / _canvas_scale);
      canvas_attr['height'] = Math.round( image_attr['height'] / _canvas_scale);
      break;

    case REGION_SHAPE.CIRCLE:
      var dx = Math.abs(canvas_attr['cx'] - _current_x);
      var dy = Math.abs(canvas_attr['cy'] - _current_y);
      var new_r = Math.sqrt( dx*dx + dy*dy );

      image_attr['r'] = Math.round(new_r * _canvas_scale);
      canvas_attr['r'] = Math.round( image_attr['r'] / _canvas_scale);
      break;

    case REGION_SHAPE.ELLIPSE:
      var new_rx = canvas_attr['rx'];
      var new_ry = canvas_attr['ry'];
      var dx = Math.abs(canvas_attr['cx'] - _current_x);
      var dy = Math.abs(canvas_attr['cy'] - _current_y);

      switch(_region_edge[1]) {
      case 5:
        new_ry = dy;
        break;

      case 6:
        new_rx = dx;
        break;

      default:
        new_rx = dx;
        new_ry = dy;
        break;
      }

      image_attr['rx'] = Math.round(new_rx * _canvas_scale);
      image_attr['ry'] = Math.round(new_ry * _canvas_scale);

      canvas_attr['rx'] = Math.round(image_attr['rx'] / _canvas_scale);
      canvas_attr['ry'] = Math.round(image_attr['ry'] / _canvas_scale);
      break;

    case REGION_SHAPE.POLYLINE: // handled by polygon
    case REGION_SHAPE.POLYGON:
      var moved_vertex_id = _region_edge[1] - POLYGON_RESIZE_VERTEX_OFFSET;

      var imx = Math.round(_current_x * _canvas_scale);
      var imy = Math.round(_current_y * _canvas_scale);
      image_attr['all_points_x'][moved_vertex_id] = imx;
      image_attr['all_points_y'][moved_vertex_id] = imy;
      canvas_attr['all_points_x'][moved_vertex_id] = Math.round( imx / _canvas_scale );
      canvas_attr['all_points_y'][moved_vertex_id] = Math.round( imy / _canvas_scale );

      if (moved_vertex_id === 0 && canvas_attr['name'] === REGION_SHAPE.POLYGON) {
        // move both first and last vertex because we
        // the initial point at the end to close path
        var n = canvas_attr['all_points_x'].length;
        image_attr['all_points_x'][n-1] = imx;
        image_attr['all_points_y'][n-1] = imy;
        canvas_attr['all_points_x'][n-1] = Math.round( imx / _canvas_scale );
        canvas_attr['all_points_y'][n-1] = Math.round( imy / _canvas_scale );
      }
      break;
    }

    _redraw_reg_canvas();
    _reg_canvas.focus();
    save_current_data_to_browser_cache();
    return;
  }

  // denotes a single click (= mouse down + mouse up)
  if ( click_dx < MOUSE_CLICK_TOL||
       click_dy < MOUSE_CLICK_TOL) {
    // if user is already drawing polygon, then each click adds a new point
    if ( _is_user_drawing_polygon ) {
      var canvas_x0 = Math.round(_click_x0);
      var canvas_y0 = Math.round(_click_y0);

      // check if the clicked point is close to the first point
      var fx0 = _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_x'][0];
      var fy0 = _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_y'][0];
      var  dx = (fx0 - canvas_x0);
      var  dy = (fy0 - canvas_y0);
      // @todo: add test for the inner area delimited by the enclosed polygon to have at least a minimum given value
      if ( Math.sqrt(dx*dx + dy*dy) <= POLYGON_VERTEX_MATCH_TOL &&
      _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_x'].length >= 3 ) {
        // user clicked on the first polygon point to close the path and the polygon has at least 3 points defined
        _is_user_drawing_polygon = false;

        // add all polygon points stored in _canvas_regions[]
        var all_points_x = _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_x'].slice(0);
        var all_points_y = _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_y'].slice(0);
        // close path - this will make any final, polygon region to contain at least 4 points
        all_points_x.push(all_points_x[0]);
        all_points_y.push(all_points_y[0]);

        var canvas_all_points_x = [];
        var canvas_all_points_y = [];

        //var points_str = '';
        for ( var i=0; i<all_points_x.length; ++i ) {
          all_points_x[i] = Math.round( all_points_x[i] * _canvas_scale );
          all_points_y[i] = Math.round( all_points_y[i] * _canvas_scale );

          canvas_all_points_x[i] = Math.round( all_points_x[i] / _canvas_scale );
          canvas_all_points_y[i] = Math.round( all_points_y[i] / _canvas_scale );

          //points_str += all_points_x[i] + ' ' + all_points_y[i] + ',';
        }
        //points_str = points_str.substring(0, points_str.length-1); // remove last comma

        var polygon_region = new ImageRegion();
        polygon_region.shape_attributes['name'] = 'polygon';
        //polygon_region.shape_attributes['points'] = points_str;
        polygon_region.shape_attributes['all_points_x'] = all_points_x;
        polygon_region.shape_attributes['all_points_y'] = all_points_y;
        _current_polygon_region_id = _img_metadata[_image_id].regions.length;
        _img_metadata[_image_id].regions.push(polygon_region);

        // update canvas
        _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_x'] = canvas_all_points_x;
        _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_y'] = canvas_all_points_y;

        // newly drawn region is automatically selected
        select_only_region(_current_polygon_region_id);

        _current_polygon_region_id = -1;
        update_attributes_panel();
        save_current_data_to_browser_cache();
      } else {
        // user clicked on a new polygon point
        _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_x'].push(canvas_x0);
        _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_y'].push(canvas_y0);
      }
    } else {
      var region_id = is_inside_region(_click_x0, _click_y0);
      if ( region_id >= 0 ) {
        // first click selects region
        _user_sel_region_id     = region_id;
        _is_region_selected     = true;
        _is_user_moving_region  = false;
        _is_user_drawing_region = false;

        // de-select all other regions if the user has not pressed Shift
        if ( !e.shiftKey ) {
          toggle_all_regions_selection(false);
        }
        set_region_select_state(region_id, true);
        update_attributes_panel();
      } else {
        if ( _is_user_drawing_region ) {
          // clear all region selection
          _is_user_drawing_region = false;
          _is_region_selected     = false;
          toggle_all_regions_selection(false);

          update_attributes_panel();
        } else {
          switch (_current_shape) {
          case REGION_SHAPE.POLYLINE: // handled by case for POLYGON
          case REGION_SHAPE.POLYGON:
            // user has clicked on the first point in a new polygon
            _is_user_drawing_polygon = true;

            var canvas_polygon_region = new ImageRegion();
            canvas_polygon_region.shape_attributes['name'] = _current_shape;
            canvas_polygon_region.shape_attributes['all_points_x'] = [Math.round(_click_x0)];
            canvas_polygon_region.shape_attributes['all_points_y'] = [Math.round(_click_y0)];
            _canvas_regions.push(canvas_polygon_region);
            _current_polygon_region_id =_canvas_regions.length - 1;
            break;

          case REGION_SHAPE.POINT:
            // user has marked a landmark point
            var point_region = new ImageRegion();
            point_region.shape_attributes['name'] = REGION_SHAPE.POINT;
            point_region.shape_attributes['cx'] = Math.round(_click_x0 * _canvas_scale);
            point_region.shape_attributes['cy'] = Math.round(_click_y0 * _canvas_scale);
            _img_metadata[_image_id].regions.push(point_region);

            var canvas_point_region = new ImageRegion();
            canvas_point_region.shape_attributes['name'] = REGION_SHAPE.POINT;
            canvas_point_region.shape_attributes['cx'] = Math.round(_click_x0);
            canvas_point_region.shape_attributes['cy'] = Math.round(_click_y0);
            _canvas_regions.push(canvas_point_region);

            update_attributes_panel();
            save_current_data_to_browser_cache();
            break;
          }
        }
      }
    }
    _redraw_reg_canvas();
    _reg_canvas.focus();
    return;
  }

  // indicates that user has finished drawing a new region
  if ( _is_user_drawing_region ) {

    _is_user_drawing_region = false;

    var region_x0, region_y0, region_x1, region_y1;
    // ensure that (x0,y0) is top-left and (x1,y1) is bottom-right
    if ( _click_x0 < _click_x1 ) {
      region_x0 = _click_x0;
      region_x1 = _click_x1;
    } else {
      region_x0 = _click_x1;
      region_x1 = _click_x0;
    }

    if ( _click_y0 < _click_y1 ) {
      region_y0 = _click_y0;
      region_y1 = _click_y1;
    } else {
      region_y0 = _click_y1;
      region_y1 = _click_y0;
    }

    var original_img_region = new ImageRegion();
    var canvas_img_region = new ImageRegion();
    var region_dx = Math.abs(region_x1 - region_x0);
    var region_dy = Math.abs(region_y1 - region_y0);

    // newly drawn region is automatically selected
    toggle_all_regions_selection(false);
    original_img_region.is_user_selected = true;
    canvas_img_region.is_user_selected = true;
    _is_region_selected = true;
    _user_sel_region_id = _canvas_regions.length; // new region's id

    if ( region_dx > REGION_MIN_DIM ||
         region_dy > REGION_MIN_DIM ) { // avoid regions with 0 dim
        switch(_current_shape) {
        case REGION_SHAPE.RECT:
          var x = Math.round(region_x0 * _canvas_scale);
          var y = Math.round(region_y0 * _canvas_scale);
          var width  = Math.round(region_dx * _canvas_scale);
          var height = Math.round(region_dy * _canvas_scale);
          original_img_region.shape_attributes['name'] = 'rect';
          original_img_region.shape_attributes['x'] = x;
          original_img_region.shape_attributes['y'] = y;
          original_img_region.shape_attributes['width'] = width;
          original_img_region.shape_attributes['height'] = height;

          canvas_img_region.shape_attributes['name'] = 'rect';
          canvas_img_region.shape_attributes['x'] = Math.round( x / _canvas_scale );
          canvas_img_region.shape_attributes['y'] = Math.round( y / _canvas_scale );
          canvas_img_region.shape_attributes['width'] = Math.round( width / _canvas_scale );
          canvas_img_region.shape_attributes['height'] = Math.round( height / _canvas_scale );

          _img_metadata[_image_id].regions.push(original_img_region);
          _canvas_regions.push(canvas_img_region);
          break;

        case REGION_SHAPE.CIRCLE:
          var cx = Math.round(region_x0 * _canvas_scale);
          var cy = Math.round(region_y0 * _canvas_scale);
          var r  = Math.round( Math.sqrt(region_dx*region_dx + region_dy*region_dy) * _canvas_scale );

          original_img_region.shape_attributes['name'] = 'circle';
          original_img_region.shape_attributes['cx'] = cx;
          original_img_region.shape_attributes['cy'] = cy;
          original_img_region.shape_attributes['r'] = r;

          canvas_img_region.shape_attributes['name'] = 'circle';
          canvas_img_region.shape_attributes['cx'] = Math.round( cx / _canvas_scale );
          canvas_img_region.shape_attributes['cy'] = Math.round( cy / _canvas_scale );
          canvas_img_region.shape_attributes['r'] = Math.round( r / _canvas_scale );

          _img_metadata[_image_id].regions.push(original_img_region);
          _canvas_regions.push(canvas_img_region);
          break;

        case REGION_SHAPE.ELLIPSE:
          var cx = Math.round(region_x0 * _canvas_scale);
          var cy = Math.round(region_y0 * _canvas_scale);
          var rx = Math.round(region_dx * _canvas_scale);
          var ry = Math.round(region_dy * _canvas_scale);

          original_img_region.shape_attributes['name'] = 'ellipse';
          original_img_region.shape_attributes['cx'] = cx;
          original_img_region.shape_attributes['cy'] = cy;
          original_img_region.shape_attributes['rx'] = rx;
          original_img_region.shape_attributes['ry'] = ry;

          canvas_img_region.shape_attributes['name'] = 'ellipse';
          canvas_img_region.shape_attributes['cx'] = Math.round( cx / _canvas_scale );
          canvas_img_region.shape_attributes['cy'] = Math.round( cy / _canvas_scale );
          canvas_img_region.shape_attributes['rx'] = Math.round( rx / _canvas_scale );
          canvas_img_region.shape_attributes['ry'] = Math.round( ry / _canvas_scale );

          _img_m_img_metadata[_image_id].regions.push(original_img_region);
          _canvas_regions.push(canvas_img_region);
          break;

        case REGION_SHAPE.POLYLINE: // handled by case REGION_SHAPE.POLYGON
        case REGION_SHAPE.POLYGON:
          // handled by _is_user_drawing polygon
          break;
        }
    } else {
      show_message('Предотвращено случайное добавление очень маленькой области.');
    }
    update_attributes_panel();
    _redraw_reg_canvas();
    _reg_canvas.focus();

    save_current_data_to_browser_cache();
    return;
  }

});

_reg_canvas.addEventListener("mouseover", function(e) {
  // change the mouse cursor icon
  _redraw_reg_canvas();
  _reg_canvas.focus();
});

_reg_canvas.addEventListener('mousemove', function(e) {
  if ( !_current_image_loaded ) {
    return;
  }

  _current_x = e.offsetX; _current_y = e.offsetY;

  if ( _is_region_selected ) {
    if ( !_is_user_resizing_region ) {
      // check if user moved mouse cursor to region boundary
      // which indicates an intention to resize the region

      _region_edge = is_on_region_corner(_current_x, _current_y);

      if ( _region_edge[0] === _user_sel_region_id ) {
        switch(_region_edge[1]) {
          // rect
        case 1: // Fall-through // top-left corner of rect
        case 3: // bottom-right corner of rect
        _reg_canvas.style.cursor = "nwse-resize";
          break;
        case 2: // Fall-through // top-right corner of rect
        case 4: // bottom-left corner of rect
        _reg_canvas.style.cursor = "nesw-resize";
          break;

        case 5: // Fall-through // top-middle point of rect
        case 7: // bottom-middle point of rect
        _reg_canvas.style.cursor = "ns-resize";
          break;
        case 6: // Fall-through // top-middle point of rect
        case 8: // bottom-middle point of rect
        _reg_canvas.style.cursor = "ew-resize";
          break;

          // circle and ellipse
        case 5:
          _reg_canvas.style.cursor = "n-resize";
          break;
        case 6:
          _reg_canvas.style.cursor = "e-resize";
          break;

        default:
          _reg_canvas.style.cursor = "default";
          break;
        }

        if (_region_edge[1] >= POLYGON_RESIZE_VERTEX_OFFSET) {
          // indicates mouse over polygon vertex
          _reg_canvas.style.cursor = "crosshair";
        }
      } else {
        var yes = is_inside_this_region(_current_x,
                                        _current_y,
                                        _user_sel_region_id);
        if (yes) {
          _reg_canvas.style.cursor = "move";
        } else {
          _reg_canvas.style.cursor = "default";
        }
      }
    }
  }

  if(_is_user_drawing_region) {
    // draw region as the user drags the mouse cursor
    if (_canvas_regions.length) {
      _redraw_reg_canvas(); // clear old intermediate rectangle
    } else {
      // first region being drawn, just clear the full region canvas
      _reg_ctx.clearRect(0, 0, _reg_canvas.width, _reg_canvas.height);
    }

    var region_x0, region_y0;

    if ( _click_x0 < _current_x ) {
      if ( _click_y0 < _current_y ) {
        region_x0 = _click_x0;
        region_y0 = _click_y0;
      } else {
        region_x0 = _click_x0;
        region_y0 = _current_y;
      }
    } else {
      if ( _click_y0 < _current_y ) {
        region_x0 = _current_x;
        region_y0 = _click_y0;
      } else {
        region_x0 = _current_x;
        region_y0 = _current_y;
      }
    }
    var dx = Math.round(Math.abs(_current_x - _click_x0));
    var dy = Math.round(Math.abs(_current_y - _click_y0));

    switch (_current_shape ) {
    case REGION_SHAPE.RECT:
      _draw_rect_region(region_x0, region_y0, dx, dy, false);
      break;

    case REGION_SHAPE.CIRCLE:
      var circle_radius = Math.round(Math.sqrt( dx*dx + dy*dy ));
      _draw_circle_region(region_x0, region_y0, circle_radius, false);
      break;

    case REGION_SHAPE.ELLIPSE:
      _draw_ellipse_region(region_x0, region_y0, dx, dy, false);
      break;

    case REGION_SHAPE.POLYGON:
      // this is handled by the if ( _is_user_drawing_polygon ) { ... }
      // see below
      break;
    }
    _reg_canvas.focus();
  }

  if ( _is_user_resizing_region ) {
    // user has clicked mouse on bounding box edge and is now moving it
    // draw region as the user drags the mouse coursor
    if (_canvas_regions.length) {
      _redraw_reg_canvas(); // clear old intermediate rectangle
    } else {
      // first region being drawn, just clear the full region canvas
      _reg_ctx.clearRect(0, 0, _reg_canvas.width, _reg_canvas.height);
    }

    var region_id = _region_edge[0];
    var attr = _canvas_regions[region_id].shape_attributes;
    console.log(attr)
    switch (attr['name']) {
    case REGION_SHAPE.RECT:
      // original rectangle
      var d = [attr['x'], attr['y'], 0, 0];
      d[2] = d[0] + attr['width'];
      d[3] = d[1] + attr['height'];

      var mx = _current_x;
      var my = _current_y;
      var preserve_aspect_ratio = false;
      // constrain (mx,my) to lie on a line connecting a diagonal of rectangle
      if (_is_ctrl_pressed ) {
        preserve_aspect_ratio = true;
      }

      rect_update_corner(_region_edge[1], d, mx, my, preserve_aspect_ratio);
      rect_standardize_coordinates(d);

      var w = Math.abs(d[2] - d[0]);
      var h = Math.abs(d[3] - d[1]);
      _draw_rect_region(d[0], d[1], w, h, true);
      break;

    case REGION_SHAPE.CIRCLE:
      var dx = Math.abs(attr['cx'] - _current_x);
      var dy = Math.abs(attr['cy'] - _current_y);
      var new_r = Math.sqrt( dx*dx + dy*dy );
      _draw_circle_region(attr['cx'],
                              attr['cy'],
                              new_r,
                              true);
      break;

    case REGION_SHAPE.ELLIPSE:
      var new_rx = attr['rx'];
      var new_ry = attr['ry'];
      var dx = Math.abs(attr['cx'] - _current_x);
      var dy = Math.abs(attr['cy'] - _current_y);
      switch(_region_edge[1]) {
      case 5:
        new_ry = dy;
        break;

      case 6:
        new_rx = dx;
        break;

      default:
        new_rx = dx;
        new_ry = dy;
        break;
      }
      _draw_ellipse_region(attr['cx'],
                               attr['cy'],
                               new_rx,
                               new_ry,
                               true);
      break;

    case REGION_SHAPE.POLYLINE: // handled by polygon
    case REGION_SHAPE.POLYGON:
      var moved_all_points_x = attr['all_points_x'].slice(0);
      var moved_all_points_y = attr['all_points_y'].slice(0);
      var moved_vertex_id = _region_edge[1] - POLYGON_RESIZE_VERTEX_OFFSET;

      moved_all_points_x[moved_vertex_id] = _current_x;
      moved_all_points_y[moved_vertex_id] = _current_y;

      if (moved_vertex_id === 0 && attr['name'] === REGION_SHAPE.POLYGON) {
        // move both first and last vertex because we
        // the initial point at the end to close path
        moved_all_points_x[moved_all_points_x.length-1] = _current_x;
        moved_all_points_y[moved_all_points_y.length-1] = _current_y;
      }
      _draw_polygon_region(moved_all_points_x,
                               moved_all_points_y,
                               true);
      break;
    }
    _reg_canvas.focus();
  }

  if ( _is_user_moving_region ) {
    // draw region as the user drags the mouse coursor
    if (_canvas_regions.length) {
      _redraw_reg_canvas(); // clear old intermediate rectangle
    } else {
      // first region being drawn, just clear the full region canvas
      _reg_ctx.clearRect(0, 0, _reg_canvas.width, _reg_canvas.height);
    }

    var move_x = (_current_x - _region_click_x);
    var move_y = (_current_y - _region_click_y);
    var attr = _canvas_regions[_user_sel_region_id].shape_attributes;

    switch (attr['name']) {
    case REGION_SHAPE.RECT:
      _draw_rect_region(attr['x'] + move_x,
                            attr['y'] + move_y,
                            attr['width'],
                            attr['height'],
                            true);
      break;

    case REGION_SHAPE.CIRCLE:
      _draw_circle_region(attr['cx'] + move_x,
                              attr['cy'] + move_y,
                              attr['r'],
                              true);
      break;

    case REGION_SHAPE.ELLIPSE:
      _draw_ellipse_region(attr['cx'] + move_x,
                               attr['cy'] + move_y,
                               attr['rx'],
                               attr['ry'],
                               true);
      break;

    case REGION_SHAPE.POLYLINE: // handled by polygon
    case REGION_SHAPE.POLYGON:
      var moved_all_points_x = attr['all_points_x'].slice(0);
      var moved_all_points_y = attr['all_points_y'].slice(0);
      for (var i=0; i<moved_all_points_x.length; ++i) {
        moved_all_points_x[i] += move_x;
        moved_all_points_y[i] += move_y;
      }
      _draw_polygon_region(moved_all_points_x,
                               moved_all_points_y,
                               true);
      break;

    case REGION_SHAPE.POINT:
      _draw_point_region(attr['cx'] + move_x,
                             attr['cy'] + move_y,
                             true);
      break;
    }
    _reg_canvas.focus();
    return;
  }

  if ( _is_user_drawing_polygon ) {
    _redraw_reg_canvas();
    var attr = _canvas_regions[_current_polygon_region_id].shape_attributes;
    var all_points_x = attr['all_points_x'];
    var all_points_y = attr['all_points_y'];
    var npts = all_points_x.length;

    var line_x = [all_points_x.slice(npts-1), _current_x];
    var line_y = [all_points_y.slice(npts-1), _current_y];
    _draw_polygon_region(line_x, line_y, false);
  }
});


//
// Canvas update routines
//
function _redraw_img_canvas() {
  if (_current_image_loaded) {
    _img_ctx.clearRect(0, 0, _img_canvas.width, _img_canvas.height);
    _img_ctx.drawImage(_img_canvas, 0, 0,
                           _img_canvas.width, _img_canvas.height);
  }
}

function _redraw_reg_canvas() {
  if (_current_image_loaded) {
    if ( _canvas_regions.length > 0 ) {
      _reg_ctx.clearRect(0, 0, _reg_canvas.width, _reg_canvas.height);
      if (_is_region_boundary_visible) {
        draw_all_regions();
      }

      if (_is_region_id_visible) {
        draw_all_region_id();
      }
    }
  }
}

function _clear_reg_canvas() {
  _reg_ctx.clearRect(0, 0, _reg_canvas.width, _reg_canvas.height);
}

function draw_all_regions() {
  for (var i=0; i < _canvas_regions.length; ++i) {
    var attr = _canvas_regions[i].shape_attributes;
    var is_selected = _canvas_regions[i].is_user_selected;

    switch( attr['name'] ) {
    case REGION_SHAPE.RECT:
      _draw_rect_region(attr['x'],
                            attr['y'],
                            attr['width'],
                            attr['height'],
                            is_selected);
      break;

    case REGION_SHAPE.CIRCLE:
      _draw_circle_region(attr['cx'],
                              attr['cy'],
                              attr['r'],
                              is_selected);
      break;

    case REGION_SHAPE.ELLIPSE:
      _draw_ellipse_region(attr['cx'],
                               attr['cy'],
                               attr['rx'],
                               attr['ry'],
                               is_selected);
      break;

    case REGION_SHAPE.POLYLINE: // handled by polygon
    case REGION_SHAPE.POLYGON:
      _draw_polygon_region(attr['all_points_x'],
                               attr['all_points_y'],
                               is_selected);
      break;

    case REGION_SHAPE.POINT:
      _draw_point_region(attr['cx'],
                             attr['cy'],
                             is_selected);
      break;
    }
  }
}

// control point for resize of region boundaries
function _draw_control_point(cx, cy) {
  _reg_ctx.beginPath();
  _reg_ctx.arc(cx, cy, REGION_POINT_RADIUS, 0, 2*Math.PI, false);
  _reg_ctx.closePath();

  _reg_ctx.fillStyle = THEME_CONTROL_POINT_COLOR;
  _reg_ctx.globalAlpha = 1.0;
  _reg_ctx.fill();
}

function _draw_rect_region(x, y, w, h, is_selected) {
  if (is_selected) {
    _draw_rect(x, y, w, h);

    _reg_ctx.strokeStyle = THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _reg_ctx.stroke();

    _reg_ctx.fillStyle   = THEME_SEL_REGION_FILL_COLOR;
    _reg_ctx.globalAlpha = THEME_SEL_REGION_OPACITY;
    _reg_ctx.fill();
    _reg_ctx.globalAlpha = 1.0;

    _draw_control_point(x  ,   y);
    _draw_control_point(x+w, y+h);
    _draw_control_point(x  , y+h);
    _draw_control_point(x+w,   y);
    _draw_control_point(x+w/2,   y);
    _draw_control_point(x+w/2, y+h);
    _draw_control_point(x    , y+h/2);
    _draw_control_point(x+w  , y+h/2);
  } else {
    // draw a fill line
    _reg_ctx.strokeStyle = THEME_BOUNDARY_FILL_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _draw_rect(x, y, w, h);
    _reg_ctx.stroke();

    if ( w > THEME_REGION_BOUNDARY_WIDTH &&
         h > THEME_REGION_BOUNDARY_WIDTH ) {
      // draw a boundary line on both sides of the fill line
      _reg_ctx.strokeStyle = THEME_REGION_BOUNDARY_WIDTH;
      _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/4;
      _draw_rect(x - THEME_REGION_BOUNDARY_WIDTH/2,
                     y - THEME_REGION_BOUNDARY_WIDTH/2,
                     w + THEME_REGION_BOUNDARY_WIDTH,
                     h + THEME_REGION_BOUNDARY_WIDTH);
      _reg_ctx.stroke();

      _draw_rect(x + THEME_REGION_BOUNDARY_WIDTH/2,
                     y + THEME_REGION_BOUNDARY_WIDTH/2,
                     w - THEME_REGION_BOUNDARY_WIDTH,
                     h - THEME_REGION_BOUNDARY_WIDTH);
      _reg_ctx.stroke();
    }
  }
}

function _draw_rect(x, y, w, h) {
  _reg_ctx.beginPath();
  _reg_ctx.moveTo(x  , y);
  _reg_ctx.lineTo(x+w, y);
  _reg_ctx.lineTo(x+w, y+h);
  _reg_ctx.lineTo(x  , y+h);
  _reg_ctx.closePath();
}

function _draw_circle_region(cx, cy, r, is_selected) {
  if (is_selected) {
    _draw_circle(cx, cy, r);

    _reg_ctx.strokeStyle = THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _reg_ctx.stroke();

    _reg_ctx.fillStyle   = THEME_SEL_REGION_FILL_COLOR;
    _reg_ctx.globalAlpha = THEME_SEL_REGION_OPACITY;
    _reg_ctx.fill();
    _reg_ctx.globalAlpha = 1.0;

    _draw_control_point(cx + r, cy);
  } else {
    // draw a fill line
    _reg_ctx.strokeStyle = THEME_BOUNDARY_FILL_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _draw_circle(cx, cy, r);
    _reg_ctx.stroke();

    if ( r > THEME_REGION_BOUNDARY_WIDTH ) {
      // draw a boundary line on both sides of the fill line
      _reg_ctx.strokeStyle = THEME_BOUNDARY_LINE_COLOR;
      _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/4;
      _draw_circle(cx, cy,
                       r - THEME_REGION_BOUNDARY_WIDTH/2);
      _reg_ctx.stroke();
      _draw_circle(cx, cy,
                       r + THEME_REGION_BOUNDARY_WIDTH/2);
      _reg_ctx.stroke();
    }
  }
}

function _draw_circle(cx, cy, r) {
  _reg_ctx.beginPath();
  _reg_ctx.arc(cx, cy, r, 0, 2*Math.PI, false);
  _reg_ctx.closePath();
}

function _draw_ellipse_region(cx, cy, rx, ry, is_selected) {
  if (is_selected) {
    _draw_ellipse(cx, cy, rx, ry);

    _reg_ctx.strokeStyle = THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _reg_ctx.stroke();

    _reg_ctx.fillStyle   = THEME_SEL_REGION_FILL_COLOR;
    _reg_ctx.globalAlpha = THEME_SEL_REGION_OPACITY;
    _reg_ctx.fill();
    _reg_ctx.globalAlpha = 1.0;

    _draw_control_point(cx + rx, cy);
    _draw_control_point(cx     , cy - ry);
  } else {
    // draw a fill line
    _reg_ctx.strokeStyle = THEME_BOUNDARY_LINE_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _draw_ellipse(cx, cy, rx, ry);
    _reg_ctx.stroke();

    if ( rx > THEME_REGION_BOUNDARY_WIDTH &&
         ry > THEME_REGION_BOUNDARY_WIDTH ) {
      // draw a boundary line on both sides of the fill line
      _reg_ctx.strokeStyle = THEME_BOUNDARY_LINE_COLOR;
      _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/4;
      _draw_ellipse(cx, cy,
                        rx + THEME_REGION_BOUNDARY_WIDTH/2,
                        ry + THEME_REGION_BOUNDARY_WIDTH/2);
      _reg_ctx.stroke();
      _draw_ellipse(cx, cy,
                        rx - THEME_REGION_BOUNDARY_WIDTH/2,
                        ry - THEME_REGION_BOUNDARY_WIDTH/2);
      _reg_ctx.stroke();
    }
  }
}

function _draw_ellipse(cx, cy, rx, ry) {
  _reg_ctx.save();

  _reg_ctx.beginPath();
  _reg_ctx.translate(cx-rx, cy-ry);
  _reg_ctx.scale(rx, ry);
  _reg_ctx.arc(1, 1, 1, 0, 2 * Math.PI, false);

  _reg_ctx.restore(); // restore to original state
  _reg_ctx.closePath();

}

function _draw_polygon_region(all_points_x, all_points_y, is_selected) {
  if ( is_selected ) {
    _reg_ctx.beginPath();
    _reg_ctx.moveTo(all_points_x[0], all_points_y[0]);
    for ( var i=1; i < all_points_x.length; ++i ) {
      _reg_ctx.lineTo(all_points_x[i], all_points_y[i]);
    }
    _reg_ctx.strokeStyle = THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _reg_ctx.stroke();

    _reg_ctx.fillStyle   = THEME_SEL_REGION_FILL_COLOR;
    _reg_ctx.globalAlpha = THEME_SEL_REGION_OPACITY;
    _reg_ctx.fill();
    _reg_ctx.globalAlpha = 1.0;

    for ( var i=0; i < all_points_x.length; ++i ) {
      _draw_control_point(all_points_x[i], all_points_y[i]);
    }
  } else {
    for ( var i=1; i < all_points_x.length; ++i ) {
      // draw a fill line
      _reg_ctx.strokeStyle = THEME_BOUNDARY_FILL_COLOR;
      _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
      _reg_ctx.beginPath();
      _reg_ctx.moveTo(all_points_x[i-1], all_points_y[i-1]);
      _reg_ctx.lineTo(all_points_x[i]  , all_points_y[i]);
      _reg_ctx.stroke();

      var slope_i = (all_points_y[i] - all_points_y[i-1]) / (all_points_x[i] - all_points_x[i-1]);
      if ( slope_i > 0 ) {
        // draw a boundary line on both sides
        _reg_ctx.strokeStyle = THEME_BOUNDARY_LINE_COLOR;
        _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/4;
        _reg_ctx.beginPath();
        _reg_ctx.moveTo(parseInt(all_points_x[i-1]) - parseInt(THEME_REGION_BOUNDARY_WIDTH/4),
                            parseInt(all_points_y[i-1]) + parseInt(THEME_REGION_BOUNDARY_WIDTH/4));
        _reg_ctx.lineTo(parseInt(all_points_x[i]) - parseInt(THEME_REGION_BOUNDARY_WIDTH/4),
                            parseInt(all_points_y[i]) + parseInt(THEME_REGION_BOUNDARY_WIDTH/4));
        _reg_ctx.stroke();
        _reg_ctx.beginPath();
        _reg_ctx.moveTo(parseInt(all_points_x[i-1]) + parseInt(THEME_REGION_BOUNDARY_WIDTH/4),
                            parseInt(all_points_y[i-1]) - parseInt(THEME_REGION_BOUNDARY_WIDTH/4));
        _reg_ctx.lineTo(parseInt(all_points_x[i]) + parseInt(THEME_REGION_BOUNDARY_WIDTH/4),
                            parseInt(all_points_y[i]) - parseInt(THEME_REGION_BOUNDARY_WIDTH/4));
        _reg_ctx.stroke();
      } else {
        // draw a boundary line on both sides
        _reg_ctx.strokeStyle = THEME_BOUNDARY_LINE_COLOR;
        _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/4;
        _reg_ctx.beginPath();
        _reg_ctx.moveTo(parseInt(all_points_x[i-1]) + parseInt(THEME_REGION_BOUNDARY_WIDTH/4),
                            parseInt(all_points_y[i-1]) + parseInt(THEME_REGION_BOUNDARY_WIDTH/4));
        _reg_ctx.lineTo(parseInt(all_points_x[i]) + parseInt(THEME_REGION_BOUNDARY_WIDTH/4),
                            parseInt(all_points_y[i]) + parseInt(THEME_REGION_BOUNDARY_WIDTH/4));
        _reg_ctx.stroke();
        _reg_ctx.beginPath();
        _reg_ctx.moveTo(parseInt(all_points_x[i-1]) - parseInt(THEME_REGION_BOUNDARY_WIDTH/4),
                            parseInt(all_points_y[i-1]) - parseInt(THEME_REGION_BOUNDARY_WIDTH/4));
        _reg_ctx.lineTo(parseInt(all_points_x[i]) - parseInt(THEME_REGION_BOUNDARY_WIDTH/4),
                            parseInt(all_points_y[i]) - parseInt(THEME_REGION_BOUNDARY_WIDTH/4));
        _reg_ctx.stroke();
      }
    }
  }
}

function _draw_point_region(cx, cy, is_selected) {
  if (is_selected) {
    _draw_point(cx, cy, REGION_POINT_RADIUS);

    _reg_ctx.strokeStyle = THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _reg_ctx.stroke();

    _reg_ctx.fillStyle   = THEME_SEL_REGION_FILL_COLOR;
    _reg_ctx.globalAlpha = THEME_SEL_REGION_OPACITY;
    _reg_ctx.fill();
    _reg_ctx.globalAlpha = 1.0;
  } else {
    // draw a fill line
    _reg_ctx.strokeStyle = THEME_BOUNDARY_FILL_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/2;
    _draw_point(cx, cy, REGION_POINT_RADIUS);
    _reg_ctx.stroke();

    // draw a boundary line on both sides of the fill line
    _reg_ctx.strokeStyle = THEME_BOUNDARY_LINE_COLOR;
    _reg_ctx.lineWidth   = THEME_REGION_BOUNDARY_WIDTH/4;
    _draw_point(cx, cy,
                    REGION_POINT_RADIUS - THEME_REGION_BOUNDARY_WIDTH/2);
    _reg_ctx.stroke();
    _draw_point(cx, cy,
                    REGION_POINT_RADIUS + THEME_REGION_BOUNDARY_WIDTH/2);
    _reg_ctx.stroke();
  }
}

function _draw_point(cx, cy, r) {
  _reg_ctx.beginPath();
  _reg_ctx.arc(cx, cy, r, 0, 2*Math.PI, false);
  _reg_ctx.closePath();
}

function draw_all_region_id() {
  _reg_ctx.shadowColor = "transparent";
  for ( var i = 0; i < _img_metadata[_image_id].regions.length; ++i ) {
    var canvas_reg = _canvas_regions[i];

    var bbox = get_region_bounding_box(canvas_reg);
    var x = bbox[0];
    var y = bbox[1];
    var w = Math.abs(bbox[2] - bbox[0]);
    _reg_ctx.font = THEME_ATTRIBUTE_VALUE_FONT;

    var annotation_str  = (i+1).toString();
    var bgnd_rect_width = _reg_ctx.measureText(annotation_str).width * 2;

    var char_width  = _reg_ctx.measureText('M').width;
    var char_height = 1.8 * char_width;

    var r = _img_metadata[_image_id].regions[i].region_attributes;
    if ( Object.keys(r).length === 1 && w > (2*char_width) ) {
      // show the attribute value
      for (var key in r) {
        annotation_str = r[key];
      }
      var strw = _reg_ctx.measureText(annotation_str).width;

      if ( strw > w ) {
        // if text overflows, crop it
        var str_max     = Math.floor((w * annotation_str.length) / strw);
        annotation_str  = annotation_str.substr(0, str_max-1) + '.';
        bgnd_rect_width = w;
      } else {
        bgnd_rect_width = strw + char_width;
      }
    }

    if (canvas_reg.shape_attributes['name'] === REGION_SHAPE.POLYGON ||
        canvas_reg.shape_attributes['name'] === REGION_SHAPE.POLYLINE) {
      // put label near the first vertex
      x = canvas_reg.shape_attributes['all_points_x'][0];
      y = canvas_reg.shape_attributes['all_points_y'][0];
    } else {
      // center the label
      x = x - (bgnd_rect_width/2 - w/2);
    }

    // first, draw a background rectangle first
    _reg_ctx.fillStyle = 'black';
    _reg_ctx.globalAlpha = 0.8;
    _reg_ctx.fillRect(Math.floor(x),
                          Math.floor(y - 1.1*char_height),
                          Math.floor(bgnd_rect_width),
                          Math.floor(char_height));

    // then, draw text over this background rectangle
    _reg_ctx.globalAlpha = 1.0;
    _reg_ctx.fillStyle = 'yellow';
    _reg_ctx.fillText(annotation_str,
                          Math.floor(x + 0.4*char_width),
                          Math.floor(y - 0.35*char_height));

  }
}

function get_region_bounding_box(region) {
  var d = region.shape_attributes;
  var bbox = new Array(4);

  switch( d['name'] ) {
  case 'rect':
    bbox[0] = d['x'];
    bbox[1] = d['y'];
    bbox[2] = d['x'] + d['width'];
    bbox[3] = d['y'] + d['height'];
    break;

  case 'circle':
    bbox[0] = d['cx'] - d['r'];
    bbox[1] = d['cy'] - d['r'];
    bbox[2] = d['cx'] + d['r'];
    bbox[3] = d['cy'] + d['r'];
    break;

  case 'ellipse':
    bbox[0] = d['cx'] - d['rx'];
    bbox[1] = d['cy'] - d['ry'];
    bbox[2] = d['cx'] + d['rx'];
    bbox[3] = d['cy'] + d['ry'];
    break;

  case 'polyline': // handled by polygon
  case 'polygon':
    var all_points_x = d['all_points_x'];
    var all_points_y = d['all_points_y'];

    var minx = Number.MAX_SAFE_INTEGER;
    var miny = Number.MAX_SAFE_INTEGER;
    var maxx = 0;
    var maxy = 0;
    for ( var i=0; i < all_points_x.length; ++i ) {
      if ( all_points_x[i] < minx ) {
        minx = all_points_x[i];
      }
      if ( all_points_x[i] > maxx ) {
        maxx = all_points_x[i];
      }
      if ( all_points_y[i] < miny ) {
        miny = all_points_y[i];
      }
      if ( all_points_y[i] > maxy ) {
        maxy = all_points_y[i];
      }
    }
    bbox[0] = minx;
    bbox[1] = miny;
    bbox[2] = maxx;
    bbox[3] = maxy;
    break;

  case 'point':
    bbox[0] = d['cx'] - REGION_POINT_RADIUS;
    bbox[1] = d['cy'] - REGION_POINT_RADIUS;
    bbox[2] = d['cx'] + REGION_POINT_RADIUS;
    bbox[3] = d['cy'] + REGION_POINT_RADIUS;
    break;
  }
  return bbox;
}

//
// Region collision routines
//
function is_inside_region(px, py, descending_order) {
  var N = _canvas_regions.length;
  if ( N === 0 ) {
    return -1;
  }
  var start, end, del;
  // traverse the canvas regions in alternating ascending
  // and descending order to solve the issue of nested regions
  if ( descending_order ) {
    start = N - 1;
    end   = -1;
    del   = -1;
  } else {
    start = 0;
    end   = N;
    del   = 1;
  }

  var i = start;
  while ( i !== end ) {
    var yes = is_inside_this_region(px, py, i);
    if (yes) {
      return i;
    }
    i = i + del;
  }
  return -1;
}

function is_inside_this_region(px, py, region_id) {
  var attr   = _canvas_regions[region_id].shape_attributes;
  var result = false;
  switch ( attr['name'] ) {
  case REGION_SHAPE.RECT:
    result = is_inside_rect(attr['x'],
                            attr['y'],
                            attr['width'],
                            attr['height'],
                            px, py);
    break;

  case REGION_SHAPE.CIRCLE:
    result = is_inside_circle(attr['cx'],
                              attr['cy'],
                              attr['r'],
                              px, py);
    break;

  case REGION_SHAPE.ELLIPSE:
    result = is_inside_ellipse(attr['cx'],
                               attr['cy'],
                               attr['rx'],
                               attr['ry'],
                               px, py);
    break;

  case REGION_SHAPE.POLYLINE: // handled by POLYGON
  case REGION_SHAPE.POLYGON:
    result = is_inside_polygon(attr['all_points_x'],
                               attr['all_points_y'],
                               px, py);
    break;

  case REGION_SHAPE.POINT:
    result = is_inside_point(attr['cx'],
                             attr['cy'],
                             px, py);
    break;
  }
  return result;
}

function is_inside_circle(cx, cy, r, px, py) {
  var dx = px - cx;
  var dy = py - cy;
  return (dx * dx + dy * dy) < r * r;
}

function is_inside_rect(x, y, w, h, px, py) {
  return px > x &&
    px < (x + w) &&
    py > y &&
    py < (y + h);
}

function is_inside_ellipse(cx, cy, rx, ry, px, py) {
  var dx = (cx - px);
  var dy = (cy - py);
  return ((dx * dx) / (rx * rx)) + ((dy * dy) / (ry * ry)) < 1;
}

// returns 0 when (px,py) is outside the polygon
// source: http://geomalgorithms.com/a03-_inclusion.html
function is_inside_polygon(all_points_x, all_points_y, px, py) {
  var wn = 0;    // the  winding number counter

  // loop through all edges of the polygon
  for ( var i = 0; i < all_points_x.length-1; ++i ) {   // edge from V[i] to  V[i+1]
    var is_left_value = is_left( all_points_x[i], all_points_y[i],
                                 all_points_x[i+1], all_points_y[i+1],
                                 px, py);

    if (all_points_y[i] <= py) {
      if (all_points_y[i+1]  > py && is_left_value > 0) {
        ++wn;
      }
    }
    else {
      if (all_points_y[i+1]  <= py && is_left_value < 0) {
        --wn;
      }
    }
  }
  if ( wn === 0 ) {
    return 0;
  }
  else {
    return 1;
  }
}

function is_inside_point(cx, cy, px, py) {
  var dx = px - cx;
  var dy = py - cy;
  var r2 = POLYGON_VERTEX_MATCH_TOL * POLYGON_VERTEX_MATCH_TOL;
  return (dx * dx + dy * dy) < r2;
}

// returns
// >0 if (x2,y2) lies on the left side of line joining (x0,y0) and (x1,y1)
// =0 if (x2,y2) lies on the line joining (x0,y0) and (x1,y1)
// >0 if (x2,y2) lies on the right side of line joining (x0,y0) and (x1,y1)
// source: http://geomalgorithms.com/a03-_inclusion.html
function is_left(x0, y0, x1, y1, x2, y2) {
  return ( ((x1 - x0) * (y2 - y0))  - ((x2 -  x0) * (y1 - y0)) );
}

function is_on_region_corner(px, py) {
  var _region_edge = [-1, -1]; // region_id, corner_id [top-left=1,top-right=2,bottom-right=3,bottom-left=4]

  for ( var i = 0; i < _canvas_regions.length; ++i ) {
    var attr = _canvas_regions[i].shape_attributes;
    var result = false;
    _region_edge[0] = i;

    switch ( attr['name'] ) {
    case REGION_SHAPE.RECT:
      result = is_on_rect_edge(attr['x'],
                               attr['y'],
                               attr['width'],
                               attr['height'],
                               px, py);
      break;

    case REGION_SHAPE.CIRCLE:
      result = is_on_circle_edge(attr['cx'],
                                 attr['cy'],
                                 attr['r'],
                                 px, py);
      break;

    case REGION_SHAPE.ELLIPSE:
      result = is_on_ellipse_edge(attr['cx'],
                                  attr['cy'],
                                  attr['rx'],
                                  attr['ry'],
                                  px, py);
      break;

    case REGION_SHAPE.POLYLINE: // handled by polygon
    case REGION_SHAPE.POLYGON:
      result = is_on_polygon_vertex(attr['all_points_x'],
                                    attr['all_points_y'],
                                    px, py);
      break;

    case REGION_SHAPE.POINT:
      // since there are no edges of a point
      result = 0;
      break;
    }

    if (result > 0) {
      _region_edge[1] = result;
      return _region_edge;
    }
  }
  _region_edge[0] = -1;
  return _region_edge;
}

function is_on_rect_edge(x, y, w, h, px, py) {
  var dx0 = Math.abs(x - px);
  var dy0 = Math.abs(y - py);
  var dx1 = Math.abs(x + w - px);
  var dy1 = Math.abs(y + h - py);
  //[top-left=1,top-right=2,bottom-right=3,bottom-left=4]
  if ( dx0 < REGION_EDGE_TOL &&
       dy0 < REGION_EDGE_TOL ) {
    return 1;
  }
  if ( dx1 < REGION_EDGE_TOL &&
       dy0 < REGION_EDGE_TOL ) {
    return 2;
  }
  if ( dx1 < REGION_EDGE_TOL &&
       dy1 < REGION_EDGE_TOL ) {
    return 3;
  }

  if ( dx0 < REGION_EDGE_TOL &&
       dy1 < REGION_EDGE_TOL ) {
    return 4;
  }

  var mx0 = Math.abs(x + w/2 - px);
  var my0 = Math.abs(y + h/2 - py);
  //[top-middle=5,right-middle=6,bottom-middle=7,left-middle=8]
  if ( mx0 < REGION_EDGE_TOL &&
       dy0 < REGION_EDGE_TOL ) {
    return 5;
  }
  if ( dx1 < REGION_EDGE_TOL &&
       my0 < REGION_EDGE_TOL ) {
    return 6;
  }
  if ( mx0 < REGION_EDGE_TOL &&
       dy1 < REGION_EDGE_TOL ) {
    return 7;
  }
  if ( dx0 < REGION_EDGE_TOL &&
       my0 < REGION_EDGE_TOL ) {
    return 8;
  }

  return 0;
}

function is_on_circle_edge(cx, cy, r, px, py) {
  var dx = cx - px;
  var dy = cy - py;
  if ( Math.abs(Math.sqrt( dx*dx + dy*dy ) - r) < REGION_EDGE_TOL ) {
    var theta = Math.atan2( py - cy, px - cx );
    if ( Math.abs(theta - (Math.PI/2)) < THETA_TOL ||
         Math.abs(theta + (Math.PI/2)) < THETA_TOL) {
      return 5;
    }
    if ( Math.abs(theta) < THETA_TOL ||
         Math.abs(Math.abs(theta) - Math.PI) < THETA_TOL) {
      return 6;
    }

    if ( theta > 0 && theta < (Math.PI/2) ) {
      return 1;
    }
    if ( theta > (Math.PI/2) && theta < (Math.PI) ) {
      return 4;
    }
    if ( theta < 0 && theta > -(Math.PI/2) ) {
      return 2;
    }
    if ( theta < -(Math.PI/2) && theta > -Math.PI ) {
      return 3;
    }
  } else {
    return 0;
  }
}

function is_on_ellipse_edge(cx, cy, rx, ry, px, py) {
  var dx = (cx - px)/rx;
  var dy = (cy - py)/ry;

  if ( Math.abs(Math.sqrt( dx*dx + dy*dy ) - 1) < _ELLIPSE_EDGE_TOL ) {
    var theta = Math.atan2( py - cy, px - cx );
    if ( Math.abs(theta - (Math.PI/2)) < _THETA_TOL ||
         Math.abs(theta + (Math.PI/2)) < _THETA_TOL) {
      return 5;
    }
    if ( Math.abs(theta) < _THETA_TOL ||
         Math.abs(Math.abs(theta) - Math.PI) < _THETA_TOL) {
      return 6;
    }
  } else {
    return 0;
  }
}

function is_on_polygon_vertex(all_points_x, all_points_y, px, py) {
  var n = all_points_x.length;
  for (var i=0; i<n; ++i) {
    if ( Math.abs(all_points_x[i] - px) < POLYGON_VERTEX_MATCH_TOL &&
         Math.abs(all_points_y[i] - py) < POLYGON_VERTEX_MATCH_TOL ) {
      return (POLYGON_RESIZE_VERTEX_OFFSET+i);
    }
  }
  return 0;
}

function rect_standardize_coordinates(d) {
  // d[x0,y0,x1,y1]
  // ensures that (d[0],d[1]) is top-left corner while
  // (d[2],d[3]) is bottom-right corner
  if ( d[0] > d[2] ) {
    // swap
    var t = d[0];
    d[0] = d[2];
    d[2] = t;
  }

  if ( d[1] > d[3] ) {
    // swap
    var t = d[1];
    d[1] = d[3];
    d[3] = t;
  }
}

function rect_update_corner(corner_id, d, x, y, preserve_aspect_ratio) {
  // pre-condition : d[x0,y0,x1,y1] is standardized
  // post-condition : corner is moved ( d may not stay standardized )
  if (preserve_aspect_ratio) {
    switch(corner_id) {
    case 1: // Fall-through // top-left
    case 3: // bottom-right
      var dx = d[2] - d[0];
      var dy = d[3] - d[1];
      var norm = Math.sqrt( dx*dx + dy*dy );
      var nx = dx / norm; // x component of unit vector along the diagonal of rect
      var ny = dy / norm; // y component
      var proj = (x - d[0]) * nx + (y - d[1]) * ny;
      var proj_x = nx * proj;
      var proj_y = ny * proj;
      // constrain (mx,my) to lie on a line connecting (x0,y0) and (x1,y1)
      x = Math.round( d[0] + proj_x );
      y = Math.round( d[1] + proj_y );
      break;

    case 2: // Fall-through // top-right
    case 4: // bottom-left
      var dx = d[2] - d[0];
      var dy = d[1] - d[3];
      var norm = Math.sqrt( dx*dx + dy*dy );
      var nx = dx / norm; // x component of unit vector along the diagonal of rect
      var ny = dy / norm; // y component
      var proj = (x - d[0]) * nx + (y - d[3]) * ny;
      var proj_x = nx * proj;
      var proj_y = ny * proj;
      // constrain (mx,my) to lie on a line connecting (x0,y0) and (x1,y1)
      x = Math.round( d[0] + proj_x );
      y = Math.round( d[3] + proj_y );
      break;
    }
  }

  switch(corner_id) {
  case 1: // top-left
    d[0] = x;
    d[1] = y;
    break;

  case 3: // bottom-right
    d[2] = x;
    d[3] = y;
    break;

  case 2: // top-right
    d[2] = x;
    d[1] = y;
    break;

  case 4: // bottom-left
    d[0] = x;
    d[3] = y;
    break;

  case 5: // top-middle
    d[1] = y;
    break;

  case 6: // right-middle
    d[2] = x;
    break;

  case 7: // bottom-middle
    d[3] = y;
    break;

  case 8: // left-middle
    d[0] = x;
    break;
  }
}

function _update_ui_components() {
  if ( !_is_window_resized && _current_image_loaded ) {
    show_message('Изменение размеров окна ...');
    set_all_text_panel_display('none');
    show_all_canvas();

    _is_window_resized = true;
    show_image(_image_index);

    if (_is_canvas_zoomed) {
      reset_zoom_level();
    }
  }
}

//
// Shortcut key handlers
//

_reg_canvas.addEventListener('keyup', function(e) {
  if (_is_user_updating_attribute_value ||
      _is_user_updating_attribute_name  ||
      _is_user_adding_attribute_name) {

    return;
  }

  if ( e.KeyCode === 17 ) { // Ctrl key
    _is_ctrl_pressed = false;
  }
});

_reg_canvas.addEventListener('keydown', function(e) {
  if (_is_user_updating_attribute_value ||
      _is_user_updating_attribute_name  ||
      _is_user_adding_attribute_name) {

    return;
  }

  // user commands
  if ( e.ctrlKey ) {
    _is_ctrl_pressed = true;
    if ( e.KeyCode === 83 ) { // Ctrl + s
      download_all_region_data('csv');
      e.preventDefault();
      return;
    }

    if ( e.KeyCode === 65 ) { // Ctrl + a
      sel_all_regions();
      e.preventDefault();
      return;
    }

    if ( e.KeyCode === 67 ) { // Ctrl + c
      if (_is_region_selected ||
          _is_all_region_selected) {
        copy_sel_regions();
        e.preventDefault();
      }
      return;
    }

    if ( e.KeyCode === 86 ) { // Ctrl + v
      paste_sel_regions();
      e.preventDefault();
      return;
    }
  }

  if( e.KeyCode === 46 || e.KeyCode === 8) { // Del or Backspace
    del_sel_regions();
    e.preventDefault();
  }
  if (e.KeyCode === 78 || e.KeyCode === 39) { // n or right arrow
    move_to_next_image();
    e.preventDefault();
    return;
  }
  if (e.KeyCode === 80 || e.KeyCode === 37) { // n or right arrow
    move_to_prev_image();
    e.preventDefault();
    return;
  }
  if (e.KeyCode === 32 && _current_image_loaded) { // Space
    toggle_img_list();
    e.preventDefault();
    return;
  }

  // zoom
  if (_current_image_loaded) {
    // see: http://www.javascripter.net/faq/keycodes.htm
    if (e.KeyCode === 61 || e.KeyCode === 187) { // + for zoom in
      if (e.shiftKey) {
        zoom_in();
      } else {  // = for zoom reset
        reset_zoom_level();
      }
      return;
    }

    if (e.KeyCode === 173 || e.KeyCode === 189) { // - for zoom out
      zoom_out();
      return;
    }
  }

  if ( e.KeyCode === 27 ) { // Esc
    if (_is_user_updating_attribute_value ||
        _is_user_updating_attribute_name ||
        _is_user_adding_attribute_name) {

      _is_user_updating_attribute_value = false;
      _is_user_updating_attribute_name = false;
      _is_user_adding_attribute_name = false;
      update_attributes_panel();
    }

    if ( _is_user_resizing_region ) {
      // cancel region resizing action
      _is_user_resizing_region = false;
    }

    if ( _is_region_selected ) {
      // clear all region selections
      _is_region_selected = false;
      _user_sel_region_id = -1;
      toggle_all_regions_selection(false);
    }

    if ( _is_user_drawing_polygon ) {
      _is_user_drawing_polygon = false;
      _canvas_regions.splice(_current_polygon_region_id, 1);
    }

    if ( _is_user_drawing_region ) {
      _is_user_drawing_region = false;
    }

    if ( _is_user_resizing_region ) {
      _is_user_resizing_region = false
    }

    if ( _is_user_updating_attribute_name ||
         _is_user_updating_attribute_value) {
      _is_user_updating_attribute_name = false;
      _is_user_updating_attribute_value = false;

    }

    if ( _is_user_moving_region ) {
      _is_user_moving_region = false
    }

    _redraw_reg_canvas();
    _reg_canvas.focus();
    e.preventDefault();
    return;
  }

  if (e.KeyCode === 112) { // F1 for help
    show_getting_started_panel();
    e.preventDefault();
    return;
  }
  if (e.KeyCode === 113) { // F2 for about
    show_about_panel();
    e.preventDefault();
    return;
  }
  if ( e.KeyCode === 13 ) { // Enter key
    if ( _current_shape === REGION_SHAPE.POLYLINE ||
         _current_shape === REGION_SHAPE.POLYGON) {
      // [Enter] key is used to indicate completion of
      // polygon or polyline drawing action

      var npts =  _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_x'].length;
      if ( npts <=2 && _current_shape === REGION_SHAPE.POLYGON ) {
        show_message('Для ломанной фигуры Вы должны выделить не менее 3 точек. ' +
                     'Нажмите [Esc] для отмены нанесения области!');
        return;
      }
      if ( npts <=1 && _current_shape === REGION_SHAPE.POLYLINE ) {
        show_message('Для ломанной линии Вы должны выделить не менее 2 точек. ' +
                     'Нажмите [Esc] для отмены нанесения области!');
        return;
      }

      _is_user_drawing_polygon = false;
      add_new_polygon();

      // newly drawn region is automatically selected
      select_only_region(_current_polygon_region_id);
      _current_polygon_region_id = -1;
      update_attributes_panel();
      save_current_data_to_browser_cache();
      _redraw_reg_canvas();
      _reg_canvas.focus();
    }
  }
});

function add_new_polygon() {
  // add all polygon points stored in _canvas_regions[]
  var all_points_x = _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_x'].slice(0);
  var all_points_y = _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_y'].slice(0);

  if ( _current_shape === REGION_SHAPE.POLYGON ) {
    // close path of the polygon (the user need not connect the final vertex)
    // hence all polygons will have at least 4 points
    all_points_x.push(all_points_x[0]);
    all_points_y.push(all_points_y[0]);
  }

  var canvas_all_points_x = [];
  var canvas_all_points_y = [];

  //var points_str = '';
  for ( var i=0; i<all_points_x.length; ++i ) {
    all_points_x[i] = Math.round( all_points_x[i] * _canvas_scale );
    all_points_y[i] = Math.round( all_points_y[i] * _canvas_scale );

    canvas_all_points_x[i] = Math.round( all_points_x[i] / _canvas_scale );
    canvas_all_points_y[i] = Math.round( all_points_y[i] / _canvas_scale );
  }

  var polygon_region = new ImageRegion();
  polygon_region.shape_attributes['name'] = _current_shape;
  polygon_region.shape_attributes['all_points_x'] = all_points_x;
  polygon_region.shape_attributes['all_points_y'] = all_points_y;
  _current_polygon_region_id = _img_metadata[_image_id].regions.length;
  _img_metadata[_image_id].regions.push(polygon_region);

  // update canvas
  _canvas_regions[_current_polygon_region_id].shape_attributes['name'] = _current_shape;
  _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_x'] = canvas_all_points_x;
  _canvas_regions[_current_polygon_region_id].shape_attributes['all_points_y'] = canvas_all_points_y;
}

function del_sel_regions() {
  if ( !_current_image_loaded ) {
    show_message('Сначала загрузите изображения!');
    return;
  }

  var del_region_count = 0;
  if ( _is_all_region_selected ) {
    del_region_count = _canvas_regions.length;
    _canvas_regions.splice(0);
    _img_metadata[_image_id].regions.splice(0);
  } else {
    var sorted_sel_reg_id = [];
    for ( var i = 0; i < _canvas_regions.length; ++i ) {
      if ( _canvas_regions[i].is_user_selected ) {
        sorted_sel_reg_id.push(i);
      }
    }
    sorted_sel_reg_id.sort( function(a,b) {
      return (b-a);
    });
    for ( var i = 0; i < sorted_sel_reg_id.length; ++i ) {
      _canvas_regions.splice( sorted_sel_reg_id[i], 1);
      _img_metadata[_image_id].regions.splice( sorted_sel_reg_id[i], 1);
      del_region_count += 1;
    }
  }

  _is_all_region_selected = false;
  _is_region_selected     = false;
  _user_sel_region_id     = -1;

  if ( _canvas_regions.length === 0 ) {
    // all regions were deleted, hence clear region canvas
    _clear_reg_canvas();
  } else {
    _redraw_reg_canvas();
  }
  _reg_canvas.focus();
  update_attributes_panel();
  save_current_data_to_browser_cache();

  show_message('Удалено ' + del_region_count + ' выбранных регионов');
}

function sel_all_regions() {
  if (!_current_image_loaded) {
    show_message('Сначала загрузите изображения!');
    return;
  }

  toggle_all_regions_selection(true);
  _is_all_region_selected = true;
  _redraw_reg_canvas();
}

function copy_sel_regions() {
  if (!_current_image_loaded) {
    show_message('Сначала загрузите изображения!');
    return;
  }

  if (_is_region_selected ||
      _is_all_region_selected) {
    _copied_image_regions.splice(0);
    for ( var i = 0; i < _img_metadata[_image_id].regions.length; ++i ) {
      var img_region = _img_metadata[_image_id].regions[i];
      var canvas_region = _canvas_regions[i];
      if ( canvas_region.is_user_selected ) {
        a_copied_image_regions.push( clone_image_region(img_region) );
      }
    }
    show_message('Скопировано ' + _copied_image_regions.length +
                 ' выделенных регионов. Нажмите Ctrl + v для вставки');
  } else {
    show_message('Необходимо выбрать область!');
  }
}

function paste_sel_regions() {
  if ( !_current_image_loaded ) {
    show_message('Сначала загрузите изображения!');
    return;
  }

  if ( _copied_image_regions.length ) {
    var pasted_reg_count = 0;
    for ( var i = 0; i < _copied_image_regions.length; ++i ) {
      // ensure copied the regions are within this image's boundaries
      var bbox = get_region_bounding_box( _copied_image_regions[i] );
      if (bbox[2] < _current_image_width &&
          bbox[3] < _current_image_height) {
        var r = clone_image_region(_copied_image_regions[i]);
        _img_metadata[_image_id].regions.push(r);

        pasted_reg_count += 1;
      }
    }
    _load_canvas_regions();
    var discarded_reg_count = _copied_image_regions.length - pasted_reg_count;
    show_message('Вставлено ' + pasted_reg_count + ' областей. ' +
                 'Сброшено ' + discarded_reg_count + ' областей, выходяящих за границу изображения.');
    _redraw_reg_canvas();
    _reg_canvas.focus();
  } else {
    show_message('Чтобы вставить области, их сначала надо выделить и скопировать!');
  }
}

function move_to_prev_image() {
  if (_img_count > 0) {
    _is_region_selected = false;
    _user_sel_region_id = -1;

    if (_is_canvas_zoomed) {
      _is_canvas_zoomed = false;
      _canvas_zoom_level_index = CANVAS_DEFAULT_ZOOM_LEVEL_INDEX;
      var zoom_scale = CANVAS_ZOOM_LEVELS[_canvas_zoom_level_index];
      set_all_canvas_scale(zoom_scale);
      set_all_canvas_size(_canvas_width, _canvas_height);
      _canvas_scale = _canvas_scale_without_zoom;
    }

    var current_img_index = _image_index;
    if ( _image_index === 0 ) {
      show_image(_img_count - 1);
    } else {
      show_image(_image_index - 1);
    }

    if (typeof _hook_prev_image === 'function') {
      _hook_prev_image(current_img_index);
    }
  }
}

function move_to_next_image() {
  if (_img_count > 0) {
    _is_region_selected = false;
    _user_sel_region_id = -1;

    if (_is_canvas_zoomed) {
      _is_canvas_zoomed = false;
      _canvas_zoom_level_index = CANVAS_DEFAULT_ZOOM_LEVEL_INDEX;
      var zoom_scale = CANVAS_ZOOM_LEVELS[_canvas_zoom_level_index];
      set_all_canvas_scale(zoom_scale);
      set_all_canvas_size(_canvas_width, _canvas_height);
      _canvas_scale = _canvas_scale_without_zoom;
    }

    var current_img_index = _image_index;
    if ( _image_index === (_img_count-1) ) {
      show_image(0);
    } else {
      show_image(_image_index + 1);
    }

    if (typeof _hook_next_image === 'function') {
      _hook_next_image(current_img_index);
    }
  }
}

function reset_zoom_level() {
  if (!_current_image_loaded) {
    show_message('Сначала загрузите изображения!');
    return;
  }
  if (_is_canvas_zoomed) {
    _is_canvas_zoomed = false;
    _canvas_zoom_level_index = CANVAS_DEFAULT_ZOOM_LEVEL_INDEX;

    var zoom_scale = CANVAS_ZOOM_LEVELS[_canvas_zoom_level_index];
    set_all_canvas_scale(zoom_scale);
    set_all_canvas_size(_canvas_width, _canvas_height);
    _canvas_scale = _canvas_scale_without_zoom;

    _load_canvas_regions(); // image to canvas space transform
    _redraw_img_canvas();
    _redraw_reg_canvas();
    _reg_canvas.focus();
    show_message('Масштаб сброшено');
  } else {
    show_message('Не удается сбросить масштаб, так как масштабирование не было применено!');
  }
}

function zoom_in() {
  if (!_current_image_loaded) {
    show_message('Сначала загрузите изображения!');
    return;
  }

  if (_canvas_zoom_level_index === (CANVAS_ZOOM_LEVELS.length-1)) {
    show_message('Дальнейшее приближение невозможно!');
  } else {
    _canvas_zoom_level_index += 1;

    _is_canvas_zoomed = true;
    var zoom_scale = CANVAS_ZOOM_LEVELS[_canvas_zoom_level_index];
    set_all_canvas_scale(zoom_scale);
    set_all_canvas_size(_canvas_width  * zoom_scale,
                        _canvas_height * zoom_scale);
    _canvas_scale = _canvas_scale_without_zoom / zoom_scale;

    _load_canvas_regions(); // image to canvas space transform
    _redraw_img_canvas();
    _redraw_reg_canvas();
    _reg_canvas.focus();
    show_message('Масштаб выставлен на уровне ' + zoom_scale + 'X');
  }
}

function zoom_out() {
  if (!_current_image_loaded) {
    show_message('В этом браузере есть данные аннотации из вашего предыдущего сеанса');
    return;
  }

  if (_canvas_zoom_level_index === 0) {
    show_message('Дальнейшее отдаление невозможно!');
  } else {
    _canvas_zoom_level_index -= 1;

    _is_canvas_zoomed = true;
    var zoom_scale = CANVAS_ZOOM_LEVELS[_canvas_zoom_level_index];
    set_all_canvas_scale(zoom_scale);
    set_all_canvas_size(_canvas_width  * zoom_scale,
                        _canvas_height * zoom_scale);
    _canvas_scale = _canvas_scale_without_zoom / zoom_scale;

    _load_canvas_regions(); // image to canvas space transform
    _redraw_img_canvas();
    _redraw_reg_canvas();
    _reg_canvas.focus();
    show_message('Масштаб выставлен на уровне ' + zoom_scale + 'X');
  }
}

function toggle_region_boundary_visibility() {
  _is_region_boundary_visible = !_is_region_boundary_visible;
  _redraw_reg_canvas();
  _reg_canvas.focus();
}

function toggle_region_id_visibility() {
  _is_region_id_visible = !_is_region_id_visible;
  _redraw_reg_canvas();
  _reg_canvas.focus();
}

//
// Mouse wheel event listener
//
window.addEventListener('wheel', function(e) {
  if (!_current_image_loaded) {
    return;
  }

  if (e.ctrlKey) {
    if (e.deltaY < 0) {
      zoom_in();
    } else {
      zoom_out();
    }
    e.preventDefault();
  }
});

//
// Persistence of annotation data in browser cache (i.e. localStorage)
//

function check_local_storage() {
  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
  try {
    var x = '_storage_test_';
    localStorage.setItem(x, x);
    localStorage.removeItem(x);
    return true;
  }
  catch(e) {
    return false;
  }
}

function save_current_data_to_browser_cache() {
  setTimeout(function() {
    if ( _is_local_storage_available &&
         ! _is_save_ongoing) {
      try {
        _is_save_ongoing = true;
        var _img_metadata = pack_metadata('json');
        var timenow = new Date().toUTCString();
        localStorage.setItem('_timestamp', timenow);
        localStorage.setItem('_img_metadata', _img_metadata[0]);
        // save attributes
        var attr = [];
        for (var attribute in _region_attributes) {
          attr.push(attribute);
        }
        localStorage.setItem('_region_attributes', JSON.stringify(attr));
        _is_save_ongoing = false;
      } catch(err) {
        _is_save_ongoing = false;
        _is_local_storage_available = false;
        show_message('Не удалось сохранить данные аннотаций в кэше браузера.');
        alert('Не удалось сохранить данные аннотаций в кэше браузера.');
        console.log('Не удалось сохранить данные аннотаций в кэше браузера');
        console.log(err.message);
      }
    }
  }, 1000);
}

function is_data_in_localStorage() {
  return localStorage.getItem('_timestamp') &&
    localStorage.getItem('_img_metadata');
}

function remove_data_from_localStorage() {
  if( check_local_storage() && is_data_in_localStorage() ) {
    localStorage.removeItem('_timestamp');
    localStorage.removeItem('_img_metadata');
  }
}

function show_localStorage_recovery_options() {
  try {
    var hstr = [];
    var saved_date = localStorage.getItem('_timestamp');
    var saved_data_size = localStorage.getItem('_img_metadata').length / 1024; // in Kb


    hstr.push('<div style="padding: 1em; border: 1px solid #cccccc;">');
    hstr.push('<h3 style="border-bottom: 1px solid #5599FF">Восстановление данных из кэша браузера</h3>');
    hstr.push('<p>В этом браузере есть данные о аннотации из вашего предыдущего сеанса\'s cache :</h3>');
    hstr.push('<ul><li>Saved on : ' + saved_date + '</li>');
    hstr.push('<li>Size : ' + Math.round(saved_data_size) + ' KB</li>');
    hstr.push('</ul>');
    hstr.push('<a title="Сохранить как JSON" style="cursor: pointer; color: blue;" onclick="download_localStorage_data(\'json\')" title="Восстановление данных об аннотациях">Save</a>');
    hstr.push('<a style="padding-left:2em; cursor: pointer; color: blue;" onclick="remove_data_from_localStorage(); show_home_panel();" title="Сброс данных о аннотациях">Discard</a>');

    hstr.push('<p style="clear: left;"><b>If you continue, the cached data will be discarded!</b></p></div>');
    _start_info_panel.innerHTML += hstr.join('');
  } catch(err) {
    show_message('Не удалось сохранить данные аннотаций в кэше браузера.');
    console.log('Не удалось сохранить данные аннотаций в кэше браузера.');
    console.log(err.message);
  }
}

function download_localStorage_data(type) {
  var saved_date = new Date( localStorage.getItem('_timestamp') );

  var localStorage_data_blob = new Blob( [localStorage.getItem('_img_metadata')],
                                         {type: 'text/json;charset=utf-8'});

  save_data_to_local_file(localStorage_data_blob, 'browser_cache_' + saved_date + '.json');
}

//
// Handlers for attributes input panel (spreadsheet like user input panel)
//
function attr_input_focus(i) {
  if ( _is_reg_attr_panel_visible ) {
    select_only_region(i);
    _redraw_reg_canvas();
  }
  _is_user_updating_attribute_value=true;
}

function attr_input_blur(i) {
  if (_is_reg_attr_panel_visible ) {
    set_region_select_state(i, false);
    _redraw_reg_canvas();
  }
  _is_user_updating_attribute_value=false;
}

// header is a Set()
// data is an array of Map() objects
function init_spreadsheet_input(type, col_headers, data, row_names) {

  if ( typeof row_names === 'undefined' ) {
    var row_names = [];
    for ( var i = 0; i < data.length; ++i ) {
      row_names[i] = i+1;
    }
  }
  var attrname = '';
  switch(type) {
  case 'region_attributes':
    attrname = 'Аттрибуты региона';
    break;

  case 'file_attributes':
    attrname = 'Аттрибуты файла';
    break;
  }

  var attrtable = document.createElement('table');
  attrtable.setAttribute('id', 'attributes_panel_table');
  var firstrow = attrtable.insertRow(0);

  // top-left cell
  var topleft_cell = firstrow.insertCell(0);
  topleft_cell.innerHTML = '';
  topleft_cell.style.border = 'none';

  for (var col_header in col_headers) {
    firstrow.insertCell(-1).innerHTML = '<b>' + col_header + '</b>';
  }
  // allow adding new attributes
  firstrow.insertCell(-1).innerHTML = '<input type="text"' +
    ' onchange="add_new_attribute(\'' + type[0] + '\', this.value)"' +
    ' value = "[ Add New ]"' +
    ' onblur="_is_user_adding_attribute_name=false; this.value = \'\';"' +
    ' onfocus="_is_user_adding_attribute_name=true; this.value = \'\';" />';

  // if multiple regions are selected, show the selected regions first
  var sel_reg_list       = [];
  var remaining_reg_list = [];
  var all_reg_list       = [];
  var region_traversal_order = [];
  if (type === 'region_attributes') {
    // count number of selected regions
    for ( var i = 0; i < data.length; ++i ) {
      all_reg_list.push(i);
      if ( data[i].is_user_selected ) {
        sel_reg_list.push(i);
      } else {
        remaining_reg_list.push(i);
      }
    }
    if ( sel_reg_list.length > 1 ) {
      region_traversal_order = sel_reg_list.concat(remaining_reg_list);
    } else {
      region_traversal_order = all_reg_list;
    }
  }

  var sel_rows = [];
  for ( var i=0; i < data.length; ++i ) {
    var row_i = i;

    // if multiple regions are selected, show the selected regions first
    var di;
    if ( type === 'region_attributes' ) {
      if ( sel_reg_list.length ) {
        row_i = region_traversal_order[row_i];
      }
      di = data[row_i].region_attributes;
    } else {
      di = data[row_i];
    }

    var row = attrtable.insertRow(-1);
    var region_id_cell              = row.insertCell(0);
    region_id_cell.innerHTML        = '' + row_names[row_i] + '';
    region_id_cell.style.fontWeight = 'bold';
    region_id_cell.style.width      = '2em';

    if (data[row_i].is_user_selected) {
      region_id_cell.style.backgroundColor = '#5599FF';
      row.style.backgroundColor = '#f2f2f2';
      sel_rows.push(row);
    }

    for ( var key in col_headers ) {
      var input_id = type[0] + '#' + key + '#' + row_i;

      if ( di.hasOwnProperty(key) ) {
        var ip_val = di[key];
        // escape all single and double quotes
        ip_val = ip_val.replace(/'/g, '\'');
        ip_val = ip_val.replace(/"/g, '&quot;');

        if ( ip_val.length > 30 ) {
          row.insertCell(-1).innerHTML = '<textarea ' +
            ' rows="' + (Math.floor(ip_val.length/30)-1) + '"' +
            ' cols="30"' +
            ' id="' +   input_id + '"' +
            ' autocomplete="on"' +
            ' onchange="update_attribute_value(\'' + input_id + '\', this.value)"' +
            ' onblur="attr_input_blur(' + row_i + ')"' +
            ' onfocus="attr_input_focus(' + row_i + ');"' +
            ' >' + ip_val + '</textarea>';
        } else {
          row.insertCell(-1).innerHTML = '<input type="text"' +
            ' id="' +   input_id + '"' +
            ' value="' + ip_val + '"' +
            ' autocomplete="on"' +
            ' onchange="update_attribute_value(\'' + input_id + '\', this.value)"' +
            ' onblur="attr_input_blur(' + row_i + ')"' +
            ' onfocus="attr_input_focus(' + row_i + ');" />';
        }
      } else {
        row.insertCell(-1).innerHTML = '<input type="text"' +
          ' id="' + input_id + '"' +
          ' onchange="update_attribute_value(\'' + input_id + '\', this.value)" ' +
          ' onblur="attr_input_blur(' + row_i + ')"' +
          ' onfocus="attr_input_focus(' + row_i + ');" />';
      }
    }
  }

  attributes_panel.replaceChild(attrtable, document.getElementById('attributes_panel_table'));
  attributes_panel.focus();

  // move vertical scrollbar automatically to show the selected region (if any)
  if ( sel_rows.length === 1 ) {
    var panelHeight = attributes_panel.offsetHeight;
    var sel_row_bottom = sel_rows[0].offsetTop + sel_rows[0].clientHeight;
    if (sel_row_bottom > panelHeight) {
      attributes_panel.scrollTop = sel_rows[0].offsetTop;
    } else {
      attributes_panel.scrollTop = 0;
    }
  } else {
    attributes_panel.scrollTop = 0;
  }
}

function update_attributes_panel(type) {
  if (_current_image_loaded &&
      _is_attributes_panel_visible) {
    if (_is_reg_attr_panel_visible) {
      update_region_attributes_input_panel();
    }

    if ( _is_file_attr_panel_visible ) {
      update_file_attributes_input_panel();
    }
    update_vertical_space();
  }
}

function update_region_attributes_input_panel() {		
	  init_spreadsheet_input('region_attributes',		
	                         _via_region_attributes,		
	                         _via_img_metadata[_via_image_id].regions);		
			
	}
function update_file_attributes_input_panel() {
  init_spreadsheet_input('file_attributes',
                         _file_attributes,
                         [_img_metadata[_image_id].file_attributes],
                         [_current_image_filename]);
}

function toggle_attributes_input_panel() {
  if( _is_reg_attr_panel_visible ) {
    toggle_reg_attr_panel();
  }
  if( _is_file_attr_panel_visible ) {
    toggle_file_attr_panel();
  }
}

function toggle_reg_attr_panel() {
  if ( _current_image_loaded ) {
    var panel = document.getElementById('reg_attr_panel_button');
    panel.classList.toggle('active');
    if ( _is_attributes_panel_visible ) {
      if( _is_reg_attr_panel_visible ) {
        attributes_panel.style.display   = 'none';
        _is_attributes_panel_visible = false;
        _is_reg_attr_panel_visible   = false;
        _reg_canvas.focus();
        // add horizontal spacer to allow scrollbar
        var hs = document.getElementById('horizontal_space');
        hs.style.height = attributes_panel.offsetHeight+'px';

      } else {
        update_region_attributes_input_panel();
        _is_reg_attr_panel_visible  = true;
        _is_file_attr_panel_visible = false;
        // de-activate the file-attr accordion panel
        var panel = document.getElementById('file_attr_panel_button');
        panel.classList.toggle('active');
        attributes_panel.focus();
      }
    } else {
      _is_attributes_panel_visible = true;
      update_region_attributes_input_panel();
      _is_reg_attr_panel_visible = true;
      attributes_panel.style.display = 'block';
      attributes_panel.focus();
    }
    update_vertical_space();
  } else {
    show_message('Сначала загрузите изображение!');
  }
}

function toggle_file_attr_panel() {
  if ( _current_image_loaded ) {
    var panel = document.getElementById('file_attr_panel_button');
    panel.classList.toggle('active');
    if ( _is_attributes_panel_visible ) {
      if( _is_file_attr_panel_visible ) {
        attributes_panel.style.display = 'none';
        _is_attributes_panel_visible = false;
        _is_file_attr_panel_visible = false;
      } else {
        update_file_attributes_input_panel();
        _is_file_attr_panel_visible = true;
        _is_reg_attr_panel_visible = false;

        // de-activate the reg-attr accordion panel
        var panel = document.getElementById('reg_attr_panel_button');
        panel.classList.toggle('active');
      }
    } else {
      _is_attributes_panel_visible = true;
      update_file_attributes_input_panel();
      _is_file_attr_panel_visible = true;
      attributes_panel.style.display = 'block';
    }
    update_vertical_space();
  } else {
    show_message('Сначала загрузите изображение!');
  }
}

// this vertical spacer is needed to allow scrollbar to show
// items like Keyboard Shortcut hidden under the attributes panel
function update_vertical_space() {
  var panel = document.getElementById('vertical_space');
  panel.style.height = attributes_panel.offsetHeight+'px';
}

function update_attribute_value(attr_id, value) {
  var attr_id_split = attr_id.split('#');
  var type = attr_id_split[0];
  var attribute_name = attr_id_split[1];
  var region_id = attr_id_split[2];

  switch(type) {
  case 'r': // region attribute
    _img_metadata[_image_id].regions[region_id].region_attributes[attribute_name] = value;
    update_region_attributes_input_panel();
    break;

  case 'f': // file attribute
    _img_metadata[_image_id].file_attributes[attribute_name] = value;
    update_file_attributes_input_panel();
    break;
  }
  if (_is_reg_attr_panel_visible) {
    set_region_select_state(region_id, false);
  }
  _redraw_reg_canvas();
  _is_user_updating_attribute_value = false;
  save_current_data_to_browser_cache();
}

function add_new_attribute(type, attribute_name) {
  switch(type) {
  case 'r': // region attribute
    if ( !_region_attributes.hasOwnProperty(attribute_name) ) {
      _region_attributes[attribute_name] = true;
    }
    update_region_attributes_input_panel();
    break;

  case 'f': // file attribute
    if ( !_file_attributes.hasOwnProperty(attribute_name) ) {
      _file_attributes[attribute_name] = true;
    }
    update_file_attributes_input_panel();
    break;
  }
  _is_user_adding_attribute_name = false;
}

//
// left sidebar toolbox maintainer
//
function toggle_accordion_panel(e) {
  e.classList.toggle('active');
  e.nextElementSibling.classList.toggle('show');
}

function toggle_leftsidebar() {
  var leftsidebar = document.getElementById('leftsidebar');
  if ( leftsidebar.style.display === 'none' ) {
    leftsidebar.style.display = 'table-cell';
    document.getElementById('leftsidebar_collapse_button').innerHTML ='&ltrif;';
  } else {
    leftsidebar.style.display = 'none';
    document.getElementById('leftsidebar_collapse_button').innerHTML ='&rtrif;';
  }
}

// source: https://www.w3schools.com/howto/howto_js_accordion.asp
function init_leftsidebar_accordion() {
  var acc = document.getElementsByClassName('leftsidebar_accordion');
  var i;
  for ( i = 0; i < acc.length; ++i ) {
    if ( acc[i].id !== 'reg_attr_panel_button' &&
         acc[i].id !== 'file_attr_panel_button' ) {

      acc[i].addEventListener('click', function() {
        this.classList.toggle('active');
        var panel = this.nextElementSibling;
        if ( panel.classList.contains('show') ) {
          panel.classList.remove('show');
        } else {
          panel.classList.add('show');
        }
      });
    }
  }
}

function is_img_fn_list_visible() {
  return img_fn_list_panel.classList.contains('show');
}

function img_loading_spinbar(show) {
  if ( is_img_fn_list_visible() ) {
    var panel = document.getElementById('loaded_img_panel_title');
    if ( show ) {
      panel.innerHTML = 'Loaded Images &nbsp;&nbsp;<div class="loading_spinbox"></div>';
    } else {
      panel.innerHTML = 'Loaded Images &nbsp;&nbsp;';
    }
  }
}

function update_img_fn_list() {
  var regex = document.getElementById('img_fn_list_regex').value;
  if ( regex === '' || regex === null ) {
    _loaded_img_fn_list_table_html = [];
    _loaded_img_fn_list_file_index = [];
    _loaded_img_fn_list_table_html.push('<ul>');
    for ( var i=0; i < _loaded_img_fn_list.length; ++i ) {
      _loaded_img_fn_list_table_html.push( img_fn_list_ith_entry_html(i) );
      _loaded_img_fn_list_file_index.push(i);
    }
    _loaded_img_fn_list_table_html.push('</ul>');
  } else {
    img_fn_list_generate_html(regex);
  }
  img_fn_list.innerHTML = _loaded_img_fn_list_table_html.join('');
  img_fn_list_scroll_to_current_file();
}

function img_fn_list_onregex() {
  img_fn_list_generate_html( document.getElementById('img_fn_list_regex').value );
  img_fn_list.innerHTML = _loaded_img_fn_list_table_html.join('');
  img_fn_list_scroll_to_current_file();
}

function img_fn_list_ith_entry_html(i) {
  var htmli = '';
  var filename = _loaded_img_fn_list[i];
  if ( i === _image_index ) {
    // highlight the current entry
    htmli += '<li id="flist'+i+'" style="cursor: default;">';
    htmli += '<b>[' + (i+1) + '] ' + filename + '</b>';
  } else {
    htmli += '<li id="flist'+i+'" onclick="jump_to_image(' + (i) + ')">';
    htmli += '[' + (i+1) + '] ' + filename;
  }
  htmli += '</li>';
  return htmli;
}

function img_fn_list_generate_html(regex) {
  _loaded_img_fn_list_table_html = [];
  _loaded_img_fn_list_file_index = [];
  _loaded_img_fn_list_table_html.push('<ul>');
  for ( var i=0; i < _loaded_img_fn_list.length; ++i ) {
    var filename = _loaded_img_fn_list[i];
    if ( filename.match(regex) !== null ) {
      _loaded_img_fn_list_table_html.push( img_fn_list_ith_entry_html(i) );
      _loaded_img_fn_list_file_index.push(i);
    }
  }
  _loaded_img_fn_list_table_html.push('</ul>');
}

function img_fn_list_scroll_to_current_file() {
  if( _loaded_img_fn_list_file_index.includes(_image_index) ) {
    var sel_file     = document.getElementById( 'flist' + _image_index );
    var panel_height = img_fn_list.clientHeight;
    if ( sel_file.offsetTop > ( img_fn_list.scrollTop + panel_height) ) {
      img_fn_list.scrollTop = sel_file.offsetTop;
    }
  }
}

function toggle_img_fn_list_visibility() {
  document.getElementById('img_fn_list_panel').classList.toggle('show');
  document.getElementById('loaded_img_panel_title').classList.toggle('active');
}
    </script>
    <!--
    <script src="vkr_snatch.js"></script>
    -->

  </body>
</html>
